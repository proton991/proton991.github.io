{"meta":{"title":"Cxy's Blog","subtitle":"","description":"","author":"Cui Xinyu","url":"https://proton991.github.com","root":"/"},"pages":[{"title":"关于","date":"2022-06-17T03:00:36.044Z","updated":"2022-06-17T03:00:36.044Z","comments":false,"path":"about/index.html","permalink":"https://proton991.github.com/about/index.html","excerpt":"","text":"About Me个人详细介绍"},{"title":"分类","date":"2022-06-17T03:00:36.044Z","updated":"2022-06-17T03:00:36.044Z","comments":false,"path":"categories/index.html","permalink":"https://proton991.github.com/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-06-17T03:00:36.044Z","updated":"2022-06-17T03:00:36.044Z","comments":false,"path":"repository/index.html","permalink":"https://proton991.github.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-06-17T03:00:36.044Z","updated":"2022-06-17T03:00:36.044Z","comments":false,"path":"tags/index.html","permalink":"https://proton991.github.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ArkRenderer Dev Log 0","slug":"ArkRenderer-Dev-Log-0","date":"2022-06-17T09:32:03.000Z","updated":"2022-06-17T12:30:58.301Z","comments":false,"path":"ArkRenderer-Dev-Log-0/","link":"","permalink":"https://proton991.github.com/ArkRenderer-Dev-Log-0/","excerpt":"","text":"Window SystemLot’s of OpenGL tutorials start with teaching people to create a black window. To create windows, we need GLFW, which provides a simple API for creating windows, contexts and surfaces, receiving input and events. Integrating 3rd party libraries in Visual Studio can be done in many ways, I prefer this way: building lib file from source code set include and library directories link libs. Step 2 &amp; 3 are done by setting properties of the project. A windows has many properties that can be configured, such as position, size, but as a starting point, we will not make it that complex. (I will improve it by reading configuration file and set these value). So a basic Window System should be something like this: 12345678910111213141516171819202122232425262728293031323334#pragma oncestruct GLFWwindow; // use forward declarationclass WindowSystem&#123;public: WindowSystem() noexcept = default; WindowSystem(WindowSystem&amp;&amp;) = default; WindowSystem&amp; operator=(WindowSystem&amp;&amp;) = default; ~WindowSystem() &#123; Shutdown(); &#125; // Disable Copying WindowSystem(const WindowSystem&amp;) = delete; WindowSystem&amp; operator=(const WindowSystem&amp;) = delete; GLFWwindow* Init(); void SwapBuffers() const; [[nodiscard]] bool IsCursorVisible() const &#123; return m_showCursor; &#125; [[nodiscard]] bool ShouldClose() const &#123; return m_shouldClose; &#125; void Update(); void Shutdown() const;private: GLFWwindow* m_window&#123; nullptr &#125;; bool m_showCursor&#123; false &#125;; bool m_shouldClose&#123; false &#125;;&#125;; Let’s take a look at the Init() function: 12345678910111213141516171819202122232425262728293031GLFWwindow* WindowSystem::Init()&#123; const int width = 1024; const int height = 768; if (!glfwInit()) &#123; std::cerr &lt;&lt; &quot;Failed to start GLFW\\n&quot;; glfwTerminate(); return nullptr; &#125; glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); glfwWindowHint(GLFW_SAMPLES, 4); // Enable 4xMSAA glfwWindowHint(GLFW_RESIZABLE, GL_FALSE); m_window = glfwCreateWindow(1024, 768, &quot;ArkRenderer&quot;, nullptr, nullptr); if (!m_window) &#123; std::cerr &lt;&lt; &quot;Failed to create GLFW m_window.\\n&quot;; glfwTerminate(); return nullptr; &#125; glfwMakeContextCurrent(m_window); glfwFocusWindow(m_window); glfwSwapInterval(1); //Enable Vsync // Center window const auto mode = glfwGetVideoMode(glfwGetPrimaryMonitor()); glfwSetWindowPos(m_window, (mode-&gt;width / 2) - width / 2, (mode-&gt;height / 2) - height / 2); glfwSetInputMode(m_window, GLFW_CURSOR, GLFW_CURSOR_DISABLED); return m_window;&#125; I used ‘magic numbers’, which should be avoided. But no worry about that, I will improve this later. 1234void WindowSystem::SwapBuffers() const&#123; glfwSwapBuffers(m_window);&#125; 123456789101112131415161718192021222324void WindowSystem::Update()&#123; glfwPollEvents(); if (Input::GetInstance().IsKeyPressed(GLFW_KEY_TAB)) &#123; m_showCursor = !m_showCursor; if (m_showCursor) &#123; glfwSetInputMode(m_window, GLFW_CURSOR, GLFW_CURSOR_NORMAL); &#125; else &#123; glfwSetInputMode(m_window, GLFW_CURSOR, GLFW_CURSOR_DISABLED); &#125; &#125; // Check if the m_window needs to be closed if (Input::GetInstance().IsKeyPressed(GLFW_KEY_ESCAPE) || glfwWindowShouldClose(m_window)) &#123; m_shouldClose = true; glfwSetWindowShouldClose(m_window, true); &#125;&#125; SwapBuffers is simple. What is glfwPollEvents? The glfwPollEvents function checks if any events are triggered (like keyboard input or mouse movement events)Update function updates window status according to keyboard input(Input.h). In AkrEngine.cpp, we use a function called ConnectToInput to handle input related with current window: 1234567891011121314151617void ConnectToInput(GLFWwindow* window)&#123; const auto resizeCallback = [](GLFWwindow* w, auto width, auto height) &#123; Input::GetInstance().windowResized(width, height); &#125;; glfwSetWindowSizeCallback(window, resizeCallback); const auto keyCallback = [](GLFWwindow* w, auto key, auto scanCode, auto action, auto mode) &#123; Input::GetInstance().keyPressed(key, scanCode, action, mode); &#125;; glfwSetKeyCallback(window, keyCallback); const auto cursorPosCallback = [](GLFWwindow* w, auto xPos, auto yPos) &#123; Input::GetInstance().mouseMoved(xPos, yPos); &#125;; glfwSetCursorPosCallback(window, cursorPosCallback);&#125; And use our simple Window System like this: 123456789101112131415void ArkEngine::Execute()&#123; while (!m_window.ShouldClose()) &#123; Input::GetInstance().Update(); m_window.Update(); m_renderer.Render(); m_window.SwapBuffers(); &#125; Shutdown();&#125;void ArkEngine::Shutdown() const&#123; m_window.Shutdown();&#125; Finally, we got this: That’s all for today!","categories":[{"name":"computer graphics","slug":"computer-graphics","permalink":"https://proton991.github.com/categories/computer-graphics/"}],"tags":[{"name":"Renderer","slug":"Renderer","permalink":"https://proton991.github.com/tags/Renderer/"},{"name":"OpenGL","slug":"OpenGL","permalink":"https://proton991.github.com/tags/OpenGL/"}]},{"title":"ArkRenderer Project","slug":"ArkRenderer-Project","date":"2022-06-17T05:51:32.000Z","updated":"2022-06-17T09:18:05.251Z","comments":false,"path":"ArkRenderer-Project/","link":"","permalink":"https://proton991.github.com/ArkRenderer-Project/","excerpt":"","text":"This article will be updated during the development OverviewArk Renderer is a 3D rendering engine, I built this by referencing OpenGL-Renderer, it’s my first computer graphic project, so it’s difficult for me to start from scratch on my own. So I intend to build my project based on other projects, the final code may look similar, but I will dive deep into the code and figure out how it works. I will write dev logs along the way. OpengGL programming and basic rendering techniques will be covered. Project StructureThe 3d engine is composed of several sub-systems. They are Window System Render System GUI System The render system is the core of the renderer. I will create “wrappers” for raw OpenGL code and pipeline. Shaders, textures, scenes and other resources will be loaded from disk and cached in memory during runtime, so a ResourceManager is needed.","categories":[{"name":"computer graphics","slug":"computer-graphics","permalink":"https://proton991.github.com/categories/computer-graphics/"}],"tags":[{"name":"Renderer","slug":"Renderer","permalink":"https://proton991.github.com/tags/Renderer/"},{"name":"OpenGL","slug":"OpenGL","permalink":"https://proton991.github.com/tags/OpenGL/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-06-17T03:00:36.044Z","updated":"2022-06-17T03:00:36.044Z","comments":true,"path":"hello-world/","link":"","permalink":"https://proton991.github.com/hello-world/","excerpt":"","text":"My first hexo blog.Keep doing and do it well.","categories":[{"name":"Talk","slug":"Talk","permalink":"https://proton991.github.com/categories/Talk/"}],"tags":[]},{"title":"LearnCpp-day0","slug":"LearnCpp-day0","date":"2022-03-15T05:18:53.000Z","updated":"2022-06-17T03:00:36.044Z","comments":false,"path":"LearnCpp-day0/","link":"","permalink":"https://proton991.github.com/LearnCpp-day0/","excerpt":"","text":"Learn CPP - OverviewC++ syntax is so complicated that I can’t grasp all of them, so I decided to learn c++ by coding some projects (apart form CG proects). Resources: MyTinySTL Cpp Interview TheAlgorithms&#x2F;C-Plus-Plus LeetCode C++ Learning Schedule Build my own version of STL. Build algorithm libarary using c++.","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://proton991.github.com/categories/Cpp/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://proton991.github.com/tags/c/"},{"name":"algorithm","slug":"algorithm","permalink":"https://proton991.github.com/tags/algorithm/"},{"name":"c++ STL","slug":"c-STL","permalink":"https://proton991.github.com/tags/c-STL/"}]},{"title":"RayTraycing-day0","slug":"RayTraycing-day0","date":"2022-03-14T12:27:21.000Z","updated":"2022-06-17T03:00:36.044Z","comments":false,"path":"RayTraycing-day0/","link":"","permalink":"https://proton991.github.com/RayTraycing-day0/","excerpt":"","text":"Overview: Learn Raytracing - from theory to practiceRay tracing is a method of graphics rendering that simulates the physical behavior of light. We can produce photorealistic images using ray tracing algorithms. I decided to learn the whole process of rendering from scratch and finally build my own raytracer. Resources: Scratchapixel Graphics Codex TU Wien Rendering Course Fundamentals of Computer Graphics, Fourth Edition (2016) Physically Based Rendering From Theory to Implementation (2016) Projects: Ray Tracing in One Weekend Smallpaint GLSL-PathTracer PSRayTracing monte-carlo-ray-tracer vk_mini_path_tracer Learning Schedule: LO0: Basics concepts, algorithms in computer graphics&#x2F;rendering. LO1: Follow Ray Tracing in One Weekend Series and code with it. LO2: Refactor the code in LO1 (referencing PSRayTracing and Smallpaint), build a retracer with GUI in which you can select scene and configure paramenters for raytracer. LO3: Learn OpenGL and Read the source code of GLSL-PathTracer thoroughly. LO4: Learn Vulkan and follow the tutorial vk_mini_path_tracer and finally build a Vulkan-pathtracer.","categories":[{"name":"computer graphics","slug":"computer-graphics","permalink":"https://proton991.github.com/categories/computer-graphics/"}],"tags":[{"name":"ray-tracing","slug":"ray-tracing","permalink":"https://proton991.github.com/tags/ray-tracing/"},{"name":"computer-graphics","slug":"computer-graphics","permalink":"https://proton991.github.com/tags/computer-graphics/"}]}],"categories":[{"name":"computer graphics","slug":"computer-graphics","permalink":"https://proton991.github.com/categories/computer-graphics/"},{"name":"Talk","slug":"Talk","permalink":"https://proton991.github.com/categories/Talk/"},{"name":"Cpp","slug":"Cpp","permalink":"https://proton991.github.com/categories/Cpp/"}],"tags":[{"name":"Renderer","slug":"Renderer","permalink":"https://proton991.github.com/tags/Renderer/"},{"name":"OpenGL","slug":"OpenGL","permalink":"https://proton991.github.com/tags/OpenGL/"},{"name":"c++","slug":"c","permalink":"https://proton991.github.com/tags/c/"},{"name":"algorithm","slug":"algorithm","permalink":"https://proton991.github.com/tags/algorithm/"},{"name":"c++ STL","slug":"c-STL","permalink":"https://proton991.github.com/tags/c-STL/"},{"name":"ray-tracing","slug":"ray-tracing","permalink":"https://proton991.github.com/tags/ray-tracing/"},{"name":"computer-graphics","slug":"computer-graphics","permalink":"https://proton991.github.com/tags/computer-graphics/"}]}
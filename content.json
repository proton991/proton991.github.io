{"meta":{"title":"Cxy's Blog","subtitle":"","description":"","author":"Cui Xinyu","url":"https://proton991.github.io","root":"/"},"pages":[{"title":"关于","date":"2022-06-17T03:00:36.044Z","updated":"2022-06-17T03:00:36.044Z","comments":false,"path":"about/index.html","permalink":"https://proton991.github.io/about/index.html","excerpt":"","text":"About Me个人详细介绍"},{"title":"分类","date":"2022-06-17T03:00:36.044Z","updated":"2022-06-17T03:00:36.044Z","comments":false,"path":"categories/index.html","permalink":"https://proton991.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-06-17T03:00:36.044Z","updated":"2022-06-17T03:00:36.044Z","comments":false,"path":"tags/index.html","permalink":"https://proton991.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-06-17T03:00:36.044Z","updated":"2022-06-17T03:00:36.044Z","comments":false,"path":"repository/index.html","permalink":"https://proton991.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"Ark VkRender Dev Log 0","slug":"Ark-VkRender-Dev-Log-0","date":"2022-07-03T09:21:10.000Z","updated":"2022-07-03T11:35:47.328Z","comments":false,"path":"Ark-VkRender-Dev-Log-0/","link":"","permalink":"https://proton991.github.io/Ark-VkRender-Dev-Log-0/","excerpt":"","text":"VkRenderer from scratchThis renderer is based on a tutorial on youtube (which itself is based on https://vulkan-tutorial.com/). My plan is to finish this in 1 month. Vulkan is a new API that I never used before, so I will explain the main concepts in detail along the way in order to fully understand it. For the theory part I will reference another serial on youtube - Vulkan Essentials. About VulkanVulkan has the following features: Graphics and compute API Cross-platform and cross-device High efficiency and low level explicit (verbose) API Major Vulkan handles: Vulkan instance: VkInstance Physical device: VkPhysicalDevice Logical device: VkDevice Vulkan Extensions 2 types: Instance Extensions: Debug features, OS-specific features, Cross-device&#x2F;instance&#x2F;process memory Device extensions: Capabilities of a physical device(RTX&#x2F;GTX) functions with EXT suffix, e.g. vkCreateDebugUtilsMessengerEXT() OverviewOur FIRST GOAL is to draw a triangle, so how? The answer is roughly about 8 steps in total: Instance and physical device selection Logical device and queue families. Window surface and swap chain. Image views and framebuffers. Render passes. Graphics pipeline. Command pools and command buffers. Main loop. We will build it step by step. First of all, a windowWe will use GLFW as our window API, so first thing todo is to build a WindowSystem, I have done something similar in another OpenGL based renderer, so I will simply paste the code here. 12345678910111213141516171819202122232425262728#pragma once#define GLFW_INCLUDE_VULKAN#include &lt;GLFW/glfw3.h&gt;#include &lt;string&gt;namespace Ark&#123; class WindowSystem &#123; private: void Init(); const int m_width; const int m_height; std::string m_windowName; GLFWwindow* m_window; public: WindowSystem(int w, int h, const std::string&amp; name); ~WindowSystem(); WindowSystem(WindowSystem&amp;&amp;) = default; // Disable copying WindowSystem(const WindowSystem&amp;) = delete; WindowSystem&amp; operator=(const WindowSystem&amp;) = delete; bool ShouldClose() const &#123; return glfwWindowShouldClose(m_window); &#125; &#125;;&#125; And its implementation: 1234567891011121314151617181920212223242526272829303132333435363738#include &quot;WindowSystem.hpp&quot;#include &lt;stdexcept&gt;namespace Ark&#123; WindowSystem::WindowSystem(const int w, const int h, const std::string&amp; name) : m_width(w), m_height(h), m_windowName(name) &#123; Init(); &#125; void WindowSystem::Init() &#123; glfwInit(); glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API); glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE); m_window = glfwCreateWindow(m_width, m_height, m_windowName.c_str(), nullptr, nullptr); &#125; WindowSystem::~WindowSystem() &#123; glfwDestroyWindow(m_window); glfwTerminate(); &#125; void WindowSystem::CreateWindowSurface(VkInstance instance, VkSurfaceKHR* surface) &#123; if (glfwCreateWindowSurface(instance, m_window, nullptr, surface) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create window surface!&quot;); &#125; &#125;&#125; We will not get involved with window resizing or input handling when drawing our first triangle, so these functions are enough for us.","categories":[{"name":"computer graphics","slug":"computer-graphics","permalink":"https://proton991.github.io/categories/computer-graphics/"}],"tags":[{"name":"Renderer","slug":"Renderer","permalink":"https://proton991.github.io/tags/Renderer/"},{"name":"Vulkan","slug":"Vulkan","permalink":"https://proton991.github.io/tags/Vulkan/"}]},{"title":"ArkRenderer Dev Log 1","slug":"ArkRenderer-Dev-Log-1","date":"2022-06-22T10:38:31.000Z","updated":"2022-06-22T14:16:01.467Z","comments":false,"path":"ArkRenderer-Dev-Log-1/","link":"","permalink":"https://proton991.github.io/ArkRenderer-Dev-Log-1/","excerpt":"","text":"Wrapping Vertex Array Object &amp; Vertex Buffer ObjectTo start drawing something we have to first give OpenGL some input vertex data. These data are stored in GPU memory, which are managed via so called vertex buffer objects(VBO). A Vertex Array Object (or VAO) is an object that describes how the vertex attributes are stored in a Vertex Buffer Object (or VBO) Using such objects in OpenGL follows the pattern “Gen..&#x2F;Bind…&#x2F;..Enable(use)”, similar to a state machine. So we use OOP to wrap them together to make our code cleaner and improve readability. A vertex attribute is an input variable to a shader that is supplied with per-vertex data. These variable can contain, for example, positions, normals or texture coordinates. We use GLVertexArray 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// GLVertexArray.hclass GLVertexArray&#123;public: enum BufferType : int &#123; Array = GL_ARRAY_BUFFER, Element = GL_ELEMENT_ARRAY_BUFFER &#125;; enum DrawMode : int &#123; Static = GL_STATIC_DRAW, Dynamic = GL_DYNAMIC_DRAW, Stream = GL_STREAM_DRAW &#125;; void Init() noexcept; void AttachBuffer(const BufferType type, const size_t size, const DrawMode mode, const void* data) noexcept; void Bind() const noexcept; void EnableAttribute(const unsigned int index, const int size, const unsigned int offset, const void* data) noexcept; void Delete() noexcept;private: unsigned int m_vao&#123;0&#125;;&#125;;// GLVertexArray.cpp#include &quot;GLVertexArray.h&quot;void GLVertexArray::Init() noexcept&#123; glGenVertexArrays(1, &amp;m_vao);&#125;void GLVertexArray::AttachBuffer(const BufferType type, const size_t size, const DrawMode mode, const void* data) noexcept&#123; unsigned int buffer; glGenBuffers(1, &amp;buffer); glBindBuffer(type, buffer); glBufferData(type, size, data, mode);&#125;void GLVertexArray::Bind() const noexcept&#123; glBindVertexArray(m_vao);&#125;void GLVertexArray::Delete() noexcept&#123; glDeleteVertexArrays(1, &amp;m_vao);&#125;void GLVertexArray::EnableAttribute(const unsigned index, const int size, const unsigned int offset, const void* data) noexcept&#123; glEnableVertexAttribArray(index); glVertexAttribPointer(index, size, GL_FLOAT, GL_FALSE, offset, data);&#125; Shader ClassesShaders are little programs that rest on the GPU, which are run for each specific section of the graphics pipeline. Below is the OpenGL rendering pipeline. There are many stages, each stage takes in input data and output data for next stage. At the beginning, we will only use vertex shader and fragment shader. We use a ShaderStage struct to store each shader stage: 12345678910111213141516171819202122namespace Graphics&#123; const std::unordered_map&lt;std::string, int&gt; TYPE2_GL_ENUM&#123; &#123;&quot;vertex&quot;, GL_VERTEX_SHADER&#125;, &#123;&quot;fragment&quot;, GL_FRAGMENT_SHADER&#125;, &#123;&quot;geometry&quot;, GL_GEOMETRY_SHADER&#125;, &#123;&quot;compute&quot;, GL_COMPUTE_SHADER&#125; &#125;; struct ShaderStage &#123; ShaderStage() noexcept = default; ShaderStage(const std::string&amp; path, const std::string&amp; type) : m_filePath(path), m_type(type) &#123; &#125; std::string m_filePath; std::string m_type; &#125;;&#125;; // namespace Graphics We manipulate shaders via id, which is the return value of glCreateShader(). Uniform variables allow us to pass data to our shaders, the difference between attribute and uniform variable is that attribute variables contain data which is vertex specific so they are reloaded with a new value from the vertex buffer for each shader invocation while the value of uniform variables remains constant across the entire draw call. Here’s how we define a Shader program: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class GLShaderProgram&#123;private: std::unordered_map&lt;std::string, int&gt; m_uniforms; GLuint m_programId&#123;0&#125;; std::string m_programName; void GetUniforms();public: GLShaderProgram(const std::string&amp; programName, const GLuint programId); ~GLShaderProgram(); void Bind() const; void DeleteProgram() const; GLShaderProgram&amp; SetUniformi(const std::string&amp; uniformName, const int value); GLShaderProgram&amp; SetUniformf(const std::string&amp; uniformName, const float value); GLShaderProgram&amp; SetUniform(const std::string&amp; uniformName, const glm::ivec2&amp; value); GLShaderProgram&amp; SetUniform(const std::string&amp; uniformName, const glm::vec2&amp; value); GLShaderProgram&amp; SetUniform(const std::string&amp; uniformName, const glm::vec3&amp; value); GLShaderProgram&amp; SetUniform(const std::string&amp; uniformName, const glm::vec4&amp; value); GLShaderProgram&amp; SetUniform(const std::string&amp; uniformName, const glm::mat3x3&amp; value); GLShaderProgram&amp; SetUniform(const std::string&amp; uniformName, const glm::mat4x4&amp; value); [[nodiscard]] auto GetProgramName() const noexcept &#123; return m_programName; &#125;&#125;;GLShaderProgram::GLShaderProgram(const std::string&amp; programName, const GLuint programID): m_programId(programID), m_programName(programName)&#123; GetUniforms();&#125;void GLShaderProgram::GetUniforms()&#123; int total = -1; glGetProgramiv(m_programId, GL_ACTIVE_UNIFORMS, &amp;total); for (auto i = 0; i &lt; total; i++) &#123; auto nameLen = -1, num = -1; GLenum type = GL_ZERO; char name[100]; glGetActiveUniform(m_programId, static_cast&lt;GLuint&gt;(i), sizeof(name) - 1, &amp;nameLen, &amp;num, &amp;type, name); name[nameLen] = 0; const auto nameStr = std::string(name); m_uniforms.try_emplace(nameStr, glGetUniformLocation(m_programId, name)); &#125;&#125; We use factory pattern to create shaders, GLShaderProgramFactory 123456789101112// GLShaderProgramFactory.hnamespace Graphics&#123; class GLShaderProgramFactory &#123; public: static std::optional&lt;GLShaderProgram&gt; CreateShaderProgram( const std::string&amp; programName, const std::vector&lt;ShaderStage&gt;&amp; stages ); &#125;;&#125;; // namespace Graphics Here’s the implementation of CreateShaderProgram 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748std::optional&lt;GLShaderProgram&gt; GLShaderProgramFactory::CreateShaderProgram( const std::string&amp; programName, const std::vector&lt;ShaderStage&gt;&amp; stages)&#123; std::cout &lt;&lt; &quot;Building shader program &quot; &lt;&lt; programName &lt;&lt; std::endl; std::vector&lt;unsigned int&gt; shaderIds; bool success = true; for (auto&amp; stage : stages) &#123; auto id = glCreateShader(TYPE2_GL_ENUM.at(stage.m_type)); shaderIds.push_back(id); auto shaderCode&#123; ResourceManager::GetInstance().LoadTextFile(stage.m_filePath) &#125;; if (!CompileStage(id, shaderCode, stage.m_type)) &#123; success = false; break; &#125; &#125; if (!success) &#123; std::cerr &lt;&lt; &quot;Shader Compilation failed\\n&quot;; for (const auto id : shaderIds) &#123; glDeleteShader(id); &#125; return std::nullopt; &#125; const unsigned int programId = glCreateProgram(); for (const auto id : shaderIds) &#123; glAttachShader(programId, id); &#125; if (!LinkProgram(programId) || !ValidateProgram(programId)) &#123; for (const auto id : shaderIds) &#123; glDetachShader(programId, id); glDeleteShader(id); &#125; glDeleteProgram(programId); std::cerr &lt;&lt; &quot;Shader Link failed\\n&quot;; return std::nullopt; &#125; for (const auto id : shaderIds) &#123; glDetachShader(programId, id); glDeleteShader(id); &#125; return std::make_optional&lt;GLShaderProgram&gt;(&#123; programName, programId &#125;);&#125; The whole process is straightforward: Load shader source code. Compile shader and check errors. Attach shader and link program. Delete the shaders as they’re linked into our program now and no longer necessary. That’s all for today! Next we will dive into model and meshes!.","categories":[{"name":"computer graphics","slug":"computer-graphics","permalink":"https://proton991.github.io/categories/computer-graphics/"}],"tags":[{"name":"Renderer","slug":"Renderer","permalink":"https://proton991.github.io/tags/Renderer/"},{"name":"OpenGL","slug":"OpenGL","permalink":"https://proton991.github.io/tags/OpenGL/"}]},{"title":"ArkRenderer Dev Log 0","slug":"ArkRenderer-Dev-Log-0","date":"2022-06-17T09:32:03.000Z","updated":"2022-06-17T12:30:58.301Z","comments":false,"path":"ArkRenderer-Dev-Log-0/","link":"","permalink":"https://proton991.github.io/ArkRenderer-Dev-Log-0/","excerpt":"","text":"Window SystemLot’s of OpenGL tutorials start with teaching people to create a black window. To create windows, we need GLFW, which provides a simple API for creating windows, contexts and surfaces, receiving input and events. Integrating 3rd party libraries in Visual Studio can be done in many ways, I prefer this way: building lib file from source code set include and library directories link libs. Step 2 &amp; 3 are done by setting properties of the project. A windows has many properties that can be configured, such as position, size, but as a starting point, we will not make it that complex. (I will improve it by reading configuration file and set these value). So a basic Window System should be something like this: 12345678910111213141516171819202122232425262728293031323334#pragma oncestruct GLFWwindow; // use forward declarationclass WindowSystem&#123;public: WindowSystem() noexcept = default; WindowSystem(WindowSystem&amp;&amp;) = default; WindowSystem&amp; operator=(WindowSystem&amp;&amp;) = default; ~WindowSystem() &#123; Shutdown(); &#125; // Disable Copying WindowSystem(const WindowSystem&amp;) = delete; WindowSystem&amp; operator=(const WindowSystem&amp;) = delete; GLFWwindow* Init(); void SwapBuffers() const; [[nodiscard]] bool IsCursorVisible() const &#123; return m_showCursor; &#125; [[nodiscard]] bool ShouldClose() const &#123; return m_shouldClose; &#125; void Update(); void Shutdown() const;private: GLFWwindow* m_window&#123; nullptr &#125;; bool m_showCursor&#123; false &#125;; bool m_shouldClose&#123; false &#125;;&#125;; Let’s take a look at the Init() function: 12345678910111213141516171819202122232425262728293031GLFWwindow* WindowSystem::Init()&#123; const int width = 1024; const int height = 768; if (!glfwInit()) &#123; std::cerr &lt;&lt; &quot;Failed to start GLFW\\n&quot;; glfwTerminate(); return nullptr; &#125; glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); glfwWindowHint(GLFW_SAMPLES, 4); // Enable 4xMSAA glfwWindowHint(GLFW_RESIZABLE, GL_FALSE); m_window = glfwCreateWindow(1024, 768, &quot;ArkRenderer&quot;, nullptr, nullptr); if (!m_window) &#123; std::cerr &lt;&lt; &quot;Failed to create GLFW m_window.\\n&quot;; glfwTerminate(); return nullptr; &#125; glfwMakeContextCurrent(m_window); glfwFocusWindow(m_window); glfwSwapInterval(1); //Enable Vsync // Center window const auto mode = glfwGetVideoMode(glfwGetPrimaryMonitor()); glfwSetWindowPos(m_window, (mode-&gt;width / 2) - width / 2, (mode-&gt;height / 2) - height / 2); glfwSetInputMode(m_window, GLFW_CURSOR, GLFW_CURSOR_DISABLED); return m_window;&#125; I used ‘magic numbers’, which should be avoided. But no worry about that, I will improve this later. 1234void WindowSystem::SwapBuffers() const&#123; glfwSwapBuffers(m_window);&#125; 123456789101112131415161718192021222324void WindowSystem::Update()&#123; glfwPollEvents(); if (Input::GetInstance().IsKeyPressed(GLFW_KEY_TAB)) &#123; m_showCursor = !m_showCursor; if (m_showCursor) &#123; glfwSetInputMode(m_window, GLFW_CURSOR, GLFW_CURSOR_NORMAL); &#125; else &#123; glfwSetInputMode(m_window, GLFW_CURSOR, GLFW_CURSOR_DISABLED); &#125; &#125; // Check if the m_window needs to be closed if (Input::GetInstance().IsKeyPressed(GLFW_KEY_ESCAPE) || glfwWindowShouldClose(m_window)) &#123; m_shouldClose = true; glfwSetWindowShouldClose(m_window, true); &#125;&#125; SwapBuffers is simple. What is glfwPollEvents? The glfwPollEvents function checks if any events are triggered (like keyboard input or mouse movement events)Update function updates window status according to keyboard input(Input.h). In AkrEngine.cpp, we use a function called ConnectToInput to handle input related with current window: 1234567891011121314151617void ConnectToInput(GLFWwindow* window)&#123; const auto resizeCallback = [](GLFWwindow* w, auto width, auto height) &#123; Input::GetInstance().windowResized(width, height); &#125;; glfwSetWindowSizeCallback(window, resizeCallback); const auto keyCallback = [](GLFWwindow* w, auto key, auto scanCode, auto action, auto mode) &#123; Input::GetInstance().keyPressed(key, scanCode, action, mode); &#125;; glfwSetKeyCallback(window, keyCallback); const auto cursorPosCallback = [](GLFWwindow* w, auto xPos, auto yPos) &#123; Input::GetInstance().mouseMoved(xPos, yPos); &#125;; glfwSetCursorPosCallback(window, cursorPosCallback);&#125; And use our simple Window System like this: 123456789101112131415void ArkEngine::Execute()&#123; while (!m_window.ShouldClose()) &#123; Input::GetInstance().Update(); m_window.Update(); m_renderer.Render(); m_window.SwapBuffers(); &#125; Shutdown();&#125;void ArkEngine::Shutdown() const&#123; m_window.Shutdown();&#125; Finally, we got this: That’s all for today!","categories":[{"name":"computer graphics","slug":"computer-graphics","permalink":"https://proton991.github.io/categories/computer-graphics/"}],"tags":[{"name":"Renderer","slug":"Renderer","permalink":"https://proton991.github.io/tags/Renderer/"},{"name":"OpenGL","slug":"OpenGL","permalink":"https://proton991.github.io/tags/OpenGL/"}]},{"title":"ArkRenderer Project","slug":"ArkRenderer-Project","date":"2022-06-17T05:51:32.000Z","updated":"2022-06-17T09:18:05.251Z","comments":false,"path":"ArkRenderer-Project/","link":"","permalink":"https://proton991.github.io/ArkRenderer-Project/","excerpt":"","text":"This article will be updated during the development OverviewArk Renderer is a 3D rendering engine, I built this by referencing OpenGL-Renderer, it’s my first computer graphic project, so it’s difficult for me to start from scratch on my own. So I intend to build my project based on other projects, the final code may look similar, but I will dive deep into the code and figure out how it works. I will write dev logs along the way. OpengGL programming and basic rendering techniques will be covered. Project StructureThe 3d engine is composed of several sub-systems. They are Window System Render System GUI System The render system is the core of the renderer. I will create “wrappers” for raw OpenGL code and pipeline. Shaders, textures, scenes and other resources will be loaded from disk and cached in memory during runtime, so a ResourceManager is needed.","categories":[{"name":"computer graphics","slug":"computer-graphics","permalink":"https://proton991.github.io/categories/computer-graphics/"}],"tags":[{"name":"Renderer","slug":"Renderer","permalink":"https://proton991.github.io/tags/Renderer/"},{"name":"OpenGL","slug":"OpenGL","permalink":"https://proton991.github.io/tags/OpenGL/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-06-17T03:00:36.044Z","updated":"2022-06-17T03:00:36.044Z","comments":true,"path":"hello-world/","link":"","permalink":"https://proton991.github.io/hello-world/","excerpt":"","text":"My first hexo blog.Keep doing and do it well.","categories":[{"name":"Talk","slug":"Talk","permalink":"https://proton991.github.io/categories/Talk/"}],"tags":[]},{"title":"LearnCpp-day0","slug":"LearnCpp-day0","date":"2022-03-15T05:18:53.000Z","updated":"2022-06-17T03:00:36.044Z","comments":false,"path":"LearnCpp-day0/","link":"","permalink":"https://proton991.github.io/LearnCpp-day0/","excerpt":"","text":"Learn CPP - OverviewC++ syntax is so complicated that I can’t grasp all of them, so I decided to learn c++ by coding some projects (apart form CG proects). Resources: MyTinySTL Cpp Interview TheAlgorithms&#x2F;C-Plus-Plus LeetCode C++ Learning Schedule Build my own version of STL. Build algorithm libarary using c++.","categories":[{"name":"Cpp","slug":"Cpp","permalink":"https://proton991.github.io/categories/Cpp/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://proton991.github.io/tags/c/"},{"name":"algorithm","slug":"algorithm","permalink":"https://proton991.github.io/tags/algorithm/"},{"name":"c++ STL","slug":"c-STL","permalink":"https://proton991.github.io/tags/c-STL/"}]},{"title":"RayTraycing-day0","slug":"RayTraycing-day0","date":"2022-03-14T12:27:21.000Z","updated":"2022-06-17T03:00:36.044Z","comments":false,"path":"RayTraycing-day0/","link":"","permalink":"https://proton991.github.io/RayTraycing-day0/","excerpt":"","text":"Overview: Learn Raytracing - from theory to practiceRay tracing is a method of graphics rendering that simulates the physical behavior of light. We can produce photorealistic images using ray tracing algorithms. I decided to learn the whole process of rendering from scratch and finally build my own raytracer. Resources: Scratchapixel Graphics Codex TU Wien Rendering Course Fundamentals of Computer Graphics, Fourth Edition (2016) Physically Based Rendering From Theory to Implementation (2016) Projects: Ray Tracing in One Weekend Smallpaint GLSL-PathTracer PSRayTracing monte-carlo-ray-tracer vk_mini_path_tracer Learning Schedule: LO0: Basics concepts, algorithms in computer graphics&#x2F;rendering. LO1: Follow Ray Tracing in One Weekend Series and code with it. LO2: Refactor the code in LO1 (referencing PSRayTracing and Smallpaint), build a retracer with GUI in which you can select scene and configure paramenters for raytracer. LO3: Learn OpenGL and Read the source code of GLSL-PathTracer thoroughly. LO4: Learn Vulkan and follow the tutorial vk_mini_path_tracer and finally build a Vulkan-pathtracer.","categories":[{"name":"computer graphics","slug":"computer-graphics","permalink":"https://proton991.github.io/categories/computer-graphics/"}],"tags":[{"name":"ray-tracing","slug":"ray-tracing","permalink":"https://proton991.github.io/tags/ray-tracing/"},{"name":"computer-graphics","slug":"computer-graphics","permalink":"https://proton991.github.io/tags/computer-graphics/"}]}],"categories":[{"name":"computer graphics","slug":"computer-graphics","permalink":"https://proton991.github.io/categories/computer-graphics/"},{"name":"Talk","slug":"Talk","permalink":"https://proton991.github.io/categories/Talk/"},{"name":"Cpp","slug":"Cpp","permalink":"https://proton991.github.io/categories/Cpp/"}],"tags":[{"name":"Renderer","slug":"Renderer","permalink":"https://proton991.github.io/tags/Renderer/"},{"name":"Vulkan","slug":"Vulkan","permalink":"https://proton991.github.io/tags/Vulkan/"},{"name":"OpenGL","slug":"OpenGL","permalink":"https://proton991.github.io/tags/OpenGL/"},{"name":"c++","slug":"c","permalink":"https://proton991.github.io/tags/c/"},{"name":"algorithm","slug":"algorithm","permalink":"https://proton991.github.io/tags/algorithm/"},{"name":"c++ STL","slug":"c-STL","permalink":"https://proton991.github.io/tags/c-STL/"},{"name":"ray-tracing","slug":"ray-tracing","permalink":"https://proton991.github.io/tags/ray-tracing/"},{"name":"computer-graphics","slug":"computer-graphics","permalink":"https://proton991.github.io/tags/computer-graphics/"}]}
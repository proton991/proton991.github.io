<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cxy&#39;s Blog</title>
  
  
  <link href="https://proton991.github.io/atom.xml" rel="self"/>
  
  <link href="https://proton991.github.io/"/>
  <updated>2022-07-27T04:56:09.331Z</updated>
  <id>https://proton991.github.io/</id>
  
  <author>
    <name>Cui Xinyu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Ark VkRenderer Dev Log 6</title>
    <link href="https://proton991.github.io/Ark-VkRenderer-Dev-Log-6/"/>
    <id>https://proton991.github.io/Ark-VkRenderer-Dev-Log-6/</id>
    <published>2022-07-05T12:25:40.000Z</published>
    <updated>2022-07-27T04:56:09.331Z</updated>
    
    <content type="html"><![CDATA[<h2 id="The-ArkModel"><a href="#The-ArkModel" class="headerlink" title="The ArkModel"></a>The <code>ArkModel</code></h2><p>Our first goal is to display a simple 3d cube. We’ve already built our graphics pipeline in the past dev logs, the final step is to provide input for the pipeline. A cube has 8 vertex, each vertex has 2 attributes, <code>position</code> and <code>color</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    glm::vec3 position&#123;&#125;;</span><br><span class="line">    glm::vec3 color&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> std::vector&lt;VkVertexInputBindingDescription&gt;</span></span><br><span class="line"><span class="function">        <span class="title">GetBindingDescriptions</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> std::vector&lt;VkVertexInputAttributeDescription&gt;</span></span><br><span class="line"><span class="function">        <span class="title">GetAttributeDescriptions</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>We have to store the vertex data int the <strong>vertex buffer</strong>, here’s how we create vertex buffer in Vulkan:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ArkModel::CreateVertexBuffers</span><span class="params">(<span class="keyword">const</span> std::vector&lt;Vertex&gt;&amp; vertices)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_vertexCount = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(vertices.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">assert</span>(m_vertexCount &gt;= <span class="number">3</span> &amp;&amp; <span class="string">&quot;Vertex count must be at least 3&quot;</span>);</span><br><span class="line">    VkDeviceSize bufferSize = <span class="built_in"><span class="keyword">sizeof</span></span>(vertices[<span class="number">0</span>]) * m_vertexCount;</span><br><span class="line">    VkBuffer stagingBuffer;</span><br><span class="line">    VkDeviceMemory stagingBufferMemory;</span><br><span class="line">    m_arkDevice.<span class="built_in">CreateBuffer</span>(bufferSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT,</span><br><span class="line">                             VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |</span><br><span class="line">                             VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,</span><br><span class="line">                             stagingBuffer, stagingBufferMemory</span><br><span class="line">                            );</span><br><span class="line">    <span class="keyword">void</span>* data;</span><br><span class="line">    <span class="built_in">vkMapMemory</span>(m_arkDevice.<span class="built_in">Device</span>(), stagingBufferMemory, <span class="number">0</span>, bufferSize,</span><br><span class="line">                <span class="number">0</span>, &amp;data);</span><br><span class="line">    <span class="built_in">memcpy</span>(data, vertices.<span class="built_in">data</span>(), <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(bufferSize));</span><br><span class="line">    <span class="built_in">vkUnmapMemory</span>(m_arkDevice.<span class="built_in">Device</span>(), stagingBufferMemory);</span><br><span class="line">    m_arkDevice.<span class="built_in">CreateBuffer</span>(bufferSize,</span><br><span class="line">                             VK_BUFFER_USAGE_VERTEX_BUFFER_BIT |</span><br><span class="line">                             VK_BUFFER_USAGE_TRANSFER_DST_BIT,</span><br><span class="line">                             VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,</span><br><span class="line">                             m_vertexBuffer, m_vertexBufferMemory</span><br><span class="line">                            );</span><br><span class="line">    m_arkDevice.<span class="built_in">CopyBuffer</span>(stagingBuffer, m_vertexBuffer, bufferSize);</span><br><span class="line">    <span class="comment">// free staging buffer</span></span><br><span class="line">    <span class="built_in">vkDestroyBuffer</span>(m_arkDevice.<span class="built_in">Device</span>(), stagingBuffer, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">vkFreeMemory</span>(m_arkDevice.<span class="built_in">Device</span>(), stagingBufferMemory, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Note that we use staging buffer here to copy host memory to device memory for better performance</strong></p><p>To reuse vertex data and reduce memory consumption, we use <strong>index buffer</strong>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ArkModel::CreateIndexBuffers</span><span class="params">(<span class="keyword">const</span> std::vector&lt;<span class="keyword">uint32_t</span>&gt;&amp; indices)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_indexCount = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(indices.<span class="built_in">size</span>());</span><br><span class="line">    m_hasIndexBuffer = m_indexCount &gt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!m_hasIndexBuffer) <span class="keyword">return</span>;</span><br><span class="line">    VkDeviceSize bufferSize = <span class="built_in"><span class="keyword">sizeof</span></span>(indices[<span class="number">0</span>]) * m_indexCount;</span><br><span class="line">    VkBuffer stagingBuffer;</span><br><span class="line">    VkDeviceMemory stagingBufferMemory;</span><br><span class="line">    m_arkDevice.<span class="built_in">CreateBuffer</span>(bufferSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT,</span><br><span class="line">                             VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |</span><br><span class="line">                             VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,</span><br><span class="line">                             stagingBuffer, stagingBufferMemory</span><br><span class="line">                            );</span><br><span class="line">    <span class="keyword">void</span>* data;</span><br><span class="line">    <span class="built_in">vkMapMemory</span>(m_arkDevice.<span class="built_in">Device</span>(), stagingBufferMemory, <span class="number">0</span>, bufferSize,</span><br><span class="line">                <span class="number">0</span>, &amp;data);</span><br><span class="line">    <span class="built_in">memcpy</span>(data, indices.<span class="built_in">data</span>(), <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(bufferSize));</span><br><span class="line">    <span class="built_in">vkUnmapMemory</span>(m_arkDevice.<span class="built_in">Device</span>(), stagingBufferMemory);</span><br><span class="line">    m_arkDevice.<span class="built_in">CreateBuffer</span>(bufferSize,</span><br><span class="line">                             VK_BUFFER_USAGE_INDEX_BUFFER_BIT |</span><br><span class="line">                             VK_BUFFER_USAGE_TRANSFER_DST_BIT,</span><br><span class="line">                             VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,</span><br><span class="line">                             m_indexBuffer, m_indexBufferMemory</span><br><span class="line">                            );</span><br><span class="line">    m_arkDevice.<span class="built_in">CopyBuffer</span>(stagingBuffer, m_indexBuffer, bufferSize);</span><br><span class="line">    <span class="comment">// free staging buffer</span></span><br><span class="line">    <span class="built_in">vkDestroyBuffer</span>(m_arkDevice.<span class="built_in">Device</span>(), stagingBuffer, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">vkFreeMemory</span>(m_arkDevice.<span class="built_in">Device</span>(), stagingBufferMemory, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We then bind our vertex buffer and draw it:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ArkModel::Bind</span><span class="params">(VkCommandBuffer commandBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VkBuffer buffers[] = &#123;m_vertexBuffer&#125;;</span><br><span class="line">    VkDeviceSize offsets[] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">vkCmdBindVertexBuffers</span>(commandBuffer, <span class="number">0</span>, <span class="number">1</span>, buffers, offsets);</span><br><span class="line">    <span class="keyword">if</span> (m_hasIndexBuffer)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vkCmdBindIndexBuffer</span>(commandBuffer, m_indexBuffer, <span class="number">0</span>,</span><br><span class="line">                             VK_INDEX_TYPE_UINT32);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ArkModel::Draw</span><span class="params">(VkCommandBuffer commandBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_hasIndexBuffer)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vkCmdDrawIndexed</span>(commandBuffer, m_indexCount, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vkCmdDraw</span>(commandBuffer, m_vertexCount, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We need to specify the binding and attribute of our vertices when creating the graphic pipeline:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ArkPipeline::CreateGraphicsPipeline</span><span class="params">(<span class="keyword">const</span> std::string&amp; vertShaderPath,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="keyword">const</span> std::string&amp; fragShaderPath,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="keyword">const</span> PipelineConfigInfo&amp;</span></span></span><br><span class="line"><span class="params"><span class="function">                                         configInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">auto</span> bindingDescriptions = ArkModel::Vertex::<span class="built_in">GetBindingDescriptions</span>();</span><br><span class="line">    <span class="keyword">auto</span> attributeDescriptions =</span><br><span class="line">        ArkModel::Vertex::<span class="built_in">GetAttributeDescriptions</span>();</span><br><span class="line">    VkPipelineVertexInputStateCreateInfo vertexInputInfo&#123;&#125;;</span><br><span class="line">    vertexInputInfo.sType =</span><br><span class="line">        VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;</span><br><span class="line">    vertexInputInfo.vertexAttributeDescriptionCount = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(</span><br><span class="line">        attributeDescriptions.<span class="built_in">size</span>());</span><br><span class="line">    vertexInputInfo.vertexBindingDescriptionCount = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(</span><br><span class="line">        bindingDescriptions.<span class="built_in">size</span>());</span><br><span class="line">    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions.</span><br><span class="line">        <span class="built_in">data</span>();</span><br><span class="line">    vertexInputInfo.pVertexBindingDescriptions = bindingDescriptions.<span class="built_in">data</span>();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="The-ArkGameObject"><a href="#The-ArkGameObject" class="headerlink" title="The ArkGameObject"></a>The <code>ArkGameObject</code></h2><p><code>ArkModel</code> is a low level representation of our objects, we may need to perform some transformation on the model or change its color, these operations are available in the <code>ArkGameObject</code> class:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ArkModel.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// libs</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> Ark</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TransformComponent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        glm::vec3 translation&#123;&#125;;</span><br><span class="line">        glm::vec3 scale&#123;<span class="number">1.f</span>, <span class="number">1.f</span>, <span class="number">1.f</span>&#125;;</span><br><span class="line">        glm::vec3 rotation&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Matrix corrsponds to Translate * Ry * Rx * Rz * Scale</span></span><br><span class="line">        <span class="comment">// Rotations correspond to Tait-bryan angles of Y(1), X(2), Z(3)</span></span><br><span class="line">        <span class="comment">// https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix</span></span><br><span class="line">        <span class="function">glm::mat4 <span class="title">Mat4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">float</span> c3 = glm::<span class="built_in">cos</span>(rotation.z);</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">float</span> s3 = glm::<span class="built_in">sin</span>(rotation.z);</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">float</span> c2 = glm::<span class="built_in">cos</span>(rotation.x);</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">float</span> s2 = glm::<span class="built_in">sin</span>(rotation.x);</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">float</span> c1 = glm::<span class="built_in">cos</span>(rotation.y);</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">float</span> s1 = glm::<span class="built_in">sin</span>(rotation.y);</span><br><span class="line">            <span class="keyword">return</span> glm::mat4&#123;</span><br><span class="line">                &#123;</span><br><span class="line">                    scale.x * (c1 * c3 + s1 * s2 * s3),</span><br><span class="line">                    scale.x * (c2 * s3),</span><br><span class="line">                    scale.x * (c1 * s2 * s3 - c3 * s1),</span><br><span class="line">                    <span class="number">0.0f</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    scale.y * (c3 * s1 * s2 - c1 * s3),</span><br><span class="line">                    scale.y * (c2 * c3),</span><br><span class="line">                    scale.y * (c1 * c3 * s2 + s1 * s3),</span><br><span class="line">                    <span class="number">0.0f</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    scale.z * (c2 * s1),</span><br><span class="line">                    scale.z * (-s2),</span><br><span class="line">                    scale.z * (c1 * c2),</span><br><span class="line">                    <span class="number">0.0f</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;translation.x, translation.y, translation.z, <span class="number">1.0f</span>&#125; &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ArkGameObject</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> IdType = <span class="keyword">unsigned</span> <span class="keyword">int</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> ArkGameObject <span class="title">Create</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">            <span class="keyword">static</span> IdType currentId = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> &#123;currentId++&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">IdType <span class="title">GetId</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_id; &#125;</span><br><span class="line">        <span class="built_in">ArkGameObject</span>(<span class="keyword">const</span> ArkGameObject&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">        ArkGameObject&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> ArkGameObject&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">        <span class="built_in">ArkGameObject</span>(ArkGameObject&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">        ArkGameObject&amp; <span class="keyword">operator</span>=(ArkGameObject&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">        std::shared_ptr&lt;ArkModel&gt; m_model&#123;&#125;;</span><br><span class="line">        glm::vec3 m_color&#123;&#125;;</span><br><span class="line">        TransformComponent m_transform&#123;&#125;;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        IdType m_id;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ArkGameObject</span>(<span class="keyword">const</span> IdType objId) : <span class="built_in">m_id</span>(objId)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Next we are going to build a movable camera and then we can display our model and observe it.</p><h2 id="The-ArkCamera"><a href="#The-ArkCamera" class="headerlink" title="The ArkCamera"></a>The <code>ArkCamera</code></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//libs</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GLM_FORCE_RADIANSk</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GLM_FORCE_DEPTH_ZERO_TO_ONE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Ark</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ArkCamera</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">ArkCamera</span>(glm::vec3 eye, glm::vec3 target, <span class="keyword">float</span> fov, <span class="keyword">float</span> aspect,</span><br><span class="line">                  <span class="keyword">float</span> near, <span class="keyword">float</span> far);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">SetOrthographicProjection</span><span class="params">(<span class="keyword">float</span> left, <span class="keyword">float</span> right, <span class="keyword">float</span> top,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="keyword">float</span> bottom, <span class="keyword">float</span> near, <span class="keyword">float</span> far)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">SetPerspectiveProjection</span><span class="params">(<span class="keyword">float</span> fovY, <span class="keyword">float</span> aspect, <span class="keyword">float</span> near,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">float</span> far)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">SetViewDirection</span><span class="params">(glm::vec3 position, glm::vec3 direction,</span></span></span><br><span class="line"><span class="params"><span class="function">                      glm::vec3 up = glm::vec3&#123;<span class="number">0.f</span>, <span class="number">-1.f</span>, <span class="number">0.f</span>&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// lock camera with a target</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">SetViewTarget</span><span class="params">(glm::vec3 position, glm::vec3 target,</span></span></span><br><span class="line"><span class="params"><span class="function">                   glm::vec3 up = glm::vec3&#123;<span class="number">0.f</span>, <span class="number">-1.f</span>, <span class="number">0.f</span>&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">SetViewYXZ</span><span class="params">(glm::vec3 position, glm::vec3 rotation)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">const</span> glm::mat4&amp; <span class="title">GetProjection</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_projectionMatrix; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">const</span> glm::mat4&amp; <span class="title">GetView</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_viewMatrix; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">SetAspect</span><span class="params">(<span class="keyword">const</span> <span class="keyword">float</span> aspect)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">            m_aspect = aspect;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">auto</span> <span class="title">GetViewMatrix</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> glm::<span class="built_in">lookAt</span>(m_position, m_position + m_front, m_up);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> optimize projection matrix calculation</span></span><br><span class="line">        <span class="function"><span class="keyword">auto</span> <span class="title">GetProjMatrix</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> glm::<span class="built_in">perspective</span>(m_fovY, m_aspect, m_near, m_far);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> deltaTime)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">Direction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">            FORWARD,</span><br><span class="line">            BACKWARD,</span><br><span class="line">            LEFT,</span><br><span class="line">            RIGHT,</span><br><span class="line">            UP,</span><br><span class="line">            DOWN</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Processes input received from mouse.</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">UpdateView</span><span class="params">(<span class="keyword">const</span> <span class="keyword">bool</span> constrainPitch = <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Processes input received from keyboard.</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">ProcessKeyboard</span><span class="params">(<span class="keyword">const</span> Direction direction,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="keyword">const</span> <span class="keyword">double</span> deltaTime)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Calculates the front vector from the Camera&#x27;s (updated) Eular Angles</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">UpdateVectors</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Camera Attributes</span></span><br><span class="line">        glm::vec3 m_position&#123;<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>&#125;;</span><br><span class="line">        glm::vec3 m_front;</span><br><span class="line">        glm::vec3 m_up&#123;<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>&#125;;</span><br><span class="line">        glm::vec3 m_right;</span><br><span class="line">        <span class="keyword">const</span> glm::vec3 m_worldUp&#123;<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> m_aspect;</span><br><span class="line">        <span class="keyword">float</span> m_fovY;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Eular Angles</span></span><br><span class="line">        <span class="keyword">float</span> m_yaw;</span><br><span class="line">        <span class="keyword">float</span> m_pitch;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> m_near&#123;<span class="number">0.1f</span>&#125;;</span><br><span class="line">        <span class="keyword">float</span> m_far&#123;<span class="number">10.0f</span>&#125;;</span><br><span class="line">        glm::mat4 m_projectionMatrix&#123;<span class="number">1.f</span>&#125;;</span><br><span class="line">        glm::mat4 m_viewMatrix&#123;<span class="number">1.f</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> m_speed&#123;<span class="number">5.0f</span>&#125;;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">float</span> m_sensitivity&#123;<span class="number">0.3f</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Mouse positions</span></span><br><span class="line">        <span class="keyword">bool</span> m_firstMouse&#123;<span class="literal">true</span>&#125;;</span><br><span class="line">        <span class="keyword">double</span> m_prevX&#123;<span class="number">0.0</span>&#125;, m_prevY&#123;<span class="number">0.0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Should we update the camera attributes?</span></span><br><span class="line">        <span class="keyword">bool</span> m_dirty&#123;<span class="literal">true</span>&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;The-ArkModel&quot;&gt;&lt;a href=&quot;#The-ArkModel&quot; class=&quot;headerlink&quot; title=&quot;The ArkModel&quot;&gt;&lt;/a&gt;The &lt;code&gt;ArkModel&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;Our first goal is</summary>
      
    
    
    
    <category term="computer graphics" scheme="https://proton991.github.io/categories/computer-graphics/"/>
    
    
    <category term="Renderer" scheme="https://proton991.github.io/tags/Renderer/"/>
    
    <category term="Vulkan" scheme="https://proton991.github.io/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>Ark VkRenderer Dev Log 5</title>
    <link href="https://proton991.github.io/Ark-VkRenderer-Dev-Log-5/"/>
    <id>https://proton991.github.io/Ark-VkRenderer-Dev-Log-5/</id>
    <published>2022-07-05T09:16:11.000Z</published>
    <updated>2022-07-26T04:12:24.683Z</updated>
    
    <content type="html"><![CDATA[<h2 id="The-ArkRenderer-and-SimpleRenderSystem"><a href="#The-ArkRenderer-and-SimpleRenderSystem" class="headerlink" title="The ArkRenderer and SimpleRenderSystem"></a>The <code>ArkRenderer</code> and <code>SimpleRenderSystem</code></h2><p>We already created our own ‘wrappers’ of <code>VkSwapChain</code>, <code>VkDevice</code>, <code>VkPipeline</code>. Now it’s time to put them together and start rendering!</p><p>Vulkan is an explicit and we have to control every <strong>frame</strong>, we need to record command for every frame and submit them.  For each frame, the drawing process starts by beginning the render pass with <code>vkCmdBeginRenderPass</code>. </p><p>Here’s how we use it:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> commandBuffer = m_arkRenderer.<span class="built_in">BeginFrame</span>())</span><br><span class="line">&#123;</span><br><span class="line">    m_arkRenderer.<span class="built_in">BeginSwapChainRenderPass</span>(commandBuffer);</span><br><span class="line">    simpleRenderSystem.<span class="built_in">RenderGameObjects</span>(</span><br><span class="line">        commandBuffer, m_gameObjects, camera);</span><br><span class="line">    m_arkRenderer.<span class="built_in">EndSwapChainRenderPass</span>(commandBuffer);</span><br><span class="line">    m_arkRenderer.<span class="built_in">EndFrame</span>();</span><br><span class="line">&#125;</span><br><span class="line">++numFramesRendered;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>When rendering our scenes, if the window size changes, we need to recreate our swap chain.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ArkRenderer::RecreateSwapChain</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> extent = m_window.<span class="built_in">GetExtent</span>();</span><br><span class="line">    <span class="keyword">while</span> (extent.width == <span class="number">0</span> || extent.height == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        extent = m_window.<span class="built_in">GetExtent</span>();</span><br><span class="line">        <span class="built_in">glfwWaitEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// wait until the swap chain is no longer being used</span></span><br><span class="line">    <span class="built_in">vkDeviceWaitIdle</span>(m_arkDevice.<span class="built_in">Device</span>());</span><br><span class="line">    <span class="keyword">if</span> (m_arkSwapChain == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_arkSwapChain = std::make_unique&lt;</span><br><span class="line">            ArkSwapChain&gt;(m_arkDevice, extent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;ArkSwapChain&gt; oldSwapChain = std::<span class="built_in">move</span>(</span><br><span class="line">            m_arkSwapChain);</span><br><span class="line"></span><br><span class="line">        m_arkSwapChain = std::make_unique&lt;ArkSwapChain&gt;(</span><br><span class="line">            m_arkDevice, extent, oldSwapChain);</span><br><span class="line">        <span class="keyword">if</span> (!oldSwapChain-&gt;<span class="built_in">CompareSwapChainFormats</span>(*m_arkSwapChain))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(</span><br><span class="line">                <span class="string">&quot;Swap chain image(or depth) format has changed!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>How do we know if the window size changes? We check the return value of <code>vkAcquireNextImageKHR</code> before we call <code>vkBeginCommandBuffer</code> and after we submit our command buffer. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (result == VK_ERROR_OUT_OF_DATE_KHR || result == VK_SUBOPTIMAL_KHR ||</span><br><span class="line">m_window.<span class="built_in">WasWindowResized</span>())</span><br><span class="line">&#123;</span><br><span class="line">    m_window.<span class="built_in">ResetWindowResizedFlag</span>();</span><br><span class="line">    <span class="built_in">RecreateSwapChain</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Let’ s take a look at our header files:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ArkRenderer.hpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;WindowSystem.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ArkDevice.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ArkSwapChain.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Ark</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ArkRenderer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">ArkRenderer</span>(WindowSystem&amp; window, ArkDevice&amp; device);</span><br><span class="line">        ~<span class="built_in">ArkRenderer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ArkRenderer</span>(<span class="keyword">const</span> ArkRenderer&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">        ArkRenderer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> ArkRenderer&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">IsFrameInProgress</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_isFrameStarted; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">VkCommandBuffer <span class="title">GetCurrentCommandBuffer</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">            <span class="built_in">assert</span>(</span><br><span class="line">                m_isFrameStarted &amp;&amp;</span><br><span class="line">                <span class="string">&quot;Cannot get command buffer when frame is not in progress&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> m_commandBuffers[m_frameIndex];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">VkRenderPass <span class="title">GetSwapChainRenderPass</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> m_arkSwapChain-&gt;<span class="built_in">GetRenderPass</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">float</span> <span class="title">GetAspectRatio</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_arkSwapChain-&gt;<span class="built_in">ExtentAspectRatio</span>(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">GetFrameIndex</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">            <span class="built_in">assert</span>(</span><br><span class="line">                m_isFrameStarted &amp;&amp;</span><br><span class="line">                <span class="string">&quot;Cannot get frame index when frame not in progress&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> m_frameIndex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">VkCommandBuffer <span class="title">BeginFrame</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">EndFrame</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">BeginSwapChainRenderPass</span><span class="params">(VkCommandBuffer commandBuffer)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">EndSwapChainRenderPass</span><span class="params">(VkCommandBuffer commandBuffer)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">CreateCommandBuffers</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">RecreateSwapChain</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">FreeCommandBuffers</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        WindowSystem&amp; m_window;</span><br><span class="line">        ArkDevice&amp; m_arkDevice;</span><br><span class="line">        std::unique_ptr&lt;ArkSwapChain&gt; m_arkSwapChain;</span><br><span class="line">        std::vector&lt;VkCommandBuffer&gt; m_commandBuffers;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">uint32_t</span> m_imageIndex;</span><br><span class="line">        <span class="keyword">int</span> m_frameIndex&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">bool</span> m_isFrameStarted&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SimpleRenderSystem.hpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ArkCamera.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ArkPipleline.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ArkGameObject.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ArkDevice.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Ark</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SimpleRenderSystem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">SimpleRenderSystem</span>(ArkDevice&amp; device, VkRenderPass renderPass);</span><br><span class="line">        ~<span class="built_in">SimpleRenderSystem</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">SimpleRenderSystem</span>(<span class="keyword">const</span> SimpleRenderSystem&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">        SimpleRenderSystem&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> SimpleRenderSystem&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">RenderGameObjects</span><span class="params">(VkCommandBuffer commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">                       std::vector&lt;ArkGameObject&gt;&amp; gameObjects,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="keyword">const</span> ArkCamera&amp; camera)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">CreatePipelineLayout</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">CreatePipeline</span><span class="params">(VkRenderPass renderPass)</span></span>;</span><br><span class="line"></span><br><span class="line">        ArkDevice&amp; m_arkDevice;</span><br><span class="line">        std::unique_ptr&lt;ArkPipeline&gt; m_arkPipeline;</span><br><span class="line">        VkPipelineLayout m_pipelineLayout;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In our engine, we only have <strong>1</strong> renderer for things like swap chain, frame, command buffers. But we can have multiple <em>Render systems</em>, each system configure its own pipeline layout and build its own pipeline. </p><p>And we can have many <em>applications</em>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FirstApp.hpp</span></span><br><span class="line"><span class="keyword">namespace</span> Ark</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">FirstApp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> WIDTH = <span class="number">800</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> HEIGHT = <span class="number">600</span>;</span><br><span class="line">        <span class="built_in">FirstApp</span>();</span><br><span class="line">        ~<span class="built_in">FirstApp</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">FirstApp</span>(<span class="keyword">const</span> FirstApp&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">        FirstApp&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> FirstApp&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">LoadGameObjects</span><span class="params">()</span></span>;</span><br><span class="line">        WindowSystem m_window&#123;WIDTH, HEIGHT, <span class="string">&quot;Hello Vulkan!&quot;</span>&#125;;</span><br><span class="line">        ArkDevice m_arkDevice&#123;m_window&#125;;</span><br><span class="line">        ArkRenderer m_arkRenderer&#123;m_window, m_arkDevice&#125;;</span><br><span class="line"></span><br><span class="line">        std::vector&lt;ArkGameObject&gt; m_gameObjects;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>That’s all for today, next we are going to build a simple cube and display it!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;The-ArkRenderer-and-SimpleRenderSystem&quot;&gt;&lt;a href=&quot;#The-ArkRenderer-and-SimpleRenderSystem&quot; class=&quot;headerlink&quot; title=&quot;The ArkRenderer </summary>
      
    
    
    
    <category term="Computer Graphics" scheme="https://proton991.github.io/categories/Computer-Graphics/"/>
    
    
    <category term="Renderer" scheme="https://proton991.github.io/tags/Renderer/"/>
    
    <category term="Vulkan" scheme="https://proton991.github.io/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>Ark VkRenderer Dev Log 4</title>
    <link href="https://proton991.github.io/Ark-VkRenderer-Dev-Log-4/"/>
    <id>https://proton991.github.io/Ark-VkRenderer-Dev-Log-4/</id>
    <published>2022-07-05T06:15:51.000Z</published>
    <updated>2022-07-26T03:14:24.713Z</updated>
    
    <content type="html"><![CDATA[<h2 id="The-ArkPipeline"><a href="#The-ArkPipeline" class="headerlink" title="The ArkPipeline"></a>The <code>ArkPipeline</code></h2><p>Next we are going to set the graphics pipeline for our renderer.</p><p>Graphic pipeline overview:</p><p><img src="/Ark-VkRenderer-Dev-Log-4/vulkan_simplified_pipeline.svg" alt="graphics-pipeline"></p><ol><li><p>The <em>input assembler</em> collects the raw vertex data from the buffers you specify and may also use an index buffer to repeat certain elements without having to duplicate the vertex data itself.</p></li><li><p>The <em>vertex shader</em> is run for every vertex and generally applies transformations to turn vertex positions from model space to screen space. It also passes per-vertex data down the pipeline.</p></li><li><p>The <em>tessellation shaders</em> allow you to subdivide geometry based on certain rules to increase the mesh quality. This is often used to make surfaces like brick walls and staircases look less flat when they are nearby.</p></li><li><p>The <em>geometry shader</em> is run on every primitive (triangle, line, point) and can discard it or output more primitives than came in. This is similar to the tessellation shader, but much more flexible. However, it is not used much in today’s applications because the performance is not that good on most graphics cards except for Intel’s integrated GPUs.</p></li><li><p>The <em>rasterization</em> stage discretizes the primitives into <em>fragments</em>. These are the pixel elements that they fill on the framebuffer. Any fragments that fall outside the screen are discarded and the attributes outputted by the vertex shader are interpolated across the fragments, as shown in the figure. Usually the fragments that are behind other primitive fragments are also discarded here because of depth testing.</p></li><li><p>The <em>fragment shader</em> is invoked for every fragment that survives and determines which framebuffer(s) the fragments are written to and with which color and depth values. It can do this using the interpolated data from the vertex shader, which can include things like texture coordinates and normals for lighting.</p></li><li><p>The <em>color blending</em> stage applies operations to mix different fragments that map to the same pixel in the framebuffer. Fragments can simply overwrite each other, add up or be mixed based upon transparency.</p></li></ol><p>Stages with a green color are known as <em>fixed-function</em> stages. These stages allow you to tweak their operations using parameters, but the way they work is predefined.</p><p>Stages with an orange color on the other hand are <code>programmable</code>, which means that you can upload your own code to the graphics card to apply exactly the operations you want. This allows you to use fragment shaders, for example, to implement anything from texturing and lighting to ray tracers. These programs run on many GPU cores simultaneously to process many objects, like vertices and fragments in parallel.</p><p>The graphics pipeline in Vulkan is almost completely immutable, so you must recreate the pipeline from scratch if you want to change shaders, bind different framebuffers or change the blend function. </p><ul><li>Disadvantage: you’ll have to create a number of pipelines that represent all of the different combinations of states you want to use in your rendering operations. </li><li>Advantages: because all of the operations you’ll be doing in the pipeline are known in advance, the driver can optimize for it much better.</li></ul><p>Some of the programmable stages are optional, our first goal is to draw a triangle, so we only need <em>vertex shader</em> stage and <em>fragment shader</em> stage.</p><h2 id="Fixed-function-stages"><a href="#Fixed-function-stages" class="headerlink" title="Fixed-function stages"></a>Fixed-function stages</h2><p>First let’s take a look at those fixed-function stages. </p><p>These stages’ initialization can be done in one function by taking in different parameters(using structs). Our first app is just drawing a triangle, so we create a function to populate default settings to these fixed-function stages.</p><p>First, we need a struct to wrap all these stages together:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PipelineConfigInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VkViewport viewport;</span><br><span class="line">    VkRect2D scissor;</span><br><span class="line">    VkPipelineViewportStateCreateInfo viewportInfo;</span><br><span class="line">    VkPipelineInputAssemblyStateCreateInfo inputAssemblyInfo;</span><br><span class="line">    VkPipelineRasterizationStateCreateInfo rasterizationInfo;</span><br><span class="line">    VkPipelineMultisampleStateCreateInfo multisampleInfo;</span><br><span class="line">    VkPipelineColorBlendAttachmentState colorBlendAttachment;</span><br><span class="line">    VkPipelineColorBlendStateCreateInfo colorBlendInfo;</span><br><span class="line">    VkPipelineDepthStencilStateCreateInfo depthStencilInfo;</span><br><span class="line">    VkPipelineLayout pipelineLayout = <span class="literal">nullptr</span>;</span><br><span class="line">    VkRenderPass renderPass = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> subpass = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">PipelineConfigInfo</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">PipelineConfigInfo</span>(<span class="keyword">const</span> PipelineConfigInfo&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    PipelineConfigInfo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> PipelineConfigInfo&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Next, define a function to populate default configurations:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ArkPipeline::DefaultPipelineConfigInfo</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PipelineConfigInfo&amp; configInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">uint32_t</span> width, <span class="keyword">uint32_t</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    configInfo.inputAssemblyInfo.sType =</span><br><span class="line">        VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;</span><br><span class="line">    configInfo.inputAssemblyInfo.topology =</span><br><span class="line">        VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;</span><br><span class="line">    configInfo.inputAssemblyInfo.primitiveRestartEnable = VK_FALSE;</span><br><span class="line"></span><br><span class="line">    configInfo.viewport.x = <span class="number">0.0f</span>;</span><br><span class="line">    configInfo.viewport.y = <span class="number">0.0f</span>;</span><br><span class="line">    configInfo.viewport.width = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(width);</span><br><span class="line">    configInfo.viewport.height = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(height);</span><br><span class="line">    configInfo.viewport.minDepth = <span class="number">0.0f</span>;</span><br><span class="line">    configInfo.viewport.maxDepth = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    configInfo.scissor.offset = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    configInfo.scissor.extent = &#123;width, height&#125;;</span><br><span class="line">    configInfo.viewportInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;</span><br><span class="line">    configInfo.viewportInfo.viewportCount = <span class="number">1</span>;</span><br><span class="line">    configInfo.viewportInfo.pViewports = &amp;configInfo.viewport;</span><br><span class="line">    configInfo.viewportInfo.scissorCount = <span class="number">1</span>;</span><br><span class="line">    configInfo.viewportInfo.pScissors = &amp;configInfo.scissor;</span><br><span class="line"></span><br><span class="line">    configInfo.rasterizationInfo.sType =</span><br><span class="line">        VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;</span><br><span class="line">    configInfo.rasterizationInfo.depthClampEnable = VK_FALSE;</span><br><span class="line">    configInfo.rasterizationInfo.rasterizerDiscardEnable = VK_FALSE;</span><br><span class="line">    configInfo.rasterizationInfo.polygonMode = VK_POLYGON_MODE_FILL;</span><br><span class="line">    configInfo.rasterizationInfo.lineWidth = <span class="number">1.0f</span>;</span><br><span class="line">    configInfo.rasterizationInfo.cullMode = VK_CULL_MODE_NONE;</span><br><span class="line">    configInfo.rasterizationInfo.frontFace = VK_FRONT_FACE_CLOCKWISE;</span><br><span class="line">    configInfo.rasterizationInfo.depthBiasEnable = VK_FALSE;</span><br><span class="line">    configInfo.rasterizationInfo.depthBiasConstantFactor = <span class="number">0.0f</span>; <span class="comment">// Optional</span></span><br><span class="line">    configInfo.rasterizationInfo.depthBiasClamp = <span class="number">0.0f</span>; <span class="comment">// Optional</span></span><br><span class="line">    configInfo.rasterizationInfo.depthBiasSlopeFactor = <span class="number">0.0f</span>; <span class="comment">// Optional</span></span><br><span class="line"></span><br><span class="line">    configInfo.multisampleInfo.sType =</span><br><span class="line">        VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;</span><br><span class="line">    configInfo.multisampleInfo.sampleShadingEnable = VK_FALSE;</span><br><span class="line">    configInfo.multisampleInfo.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;</span><br><span class="line">    configInfo.multisampleInfo.minSampleShading = <span class="number">1.0f</span>; <span class="comment">// Optional</span></span><br><span class="line">    configInfo.multisampleInfo.pSampleMask = <span class="literal">nullptr</span>; <span class="comment">// Optional</span></span><br><span class="line">    configInfo.multisampleInfo.alphaToCoverageEnable = VK_FALSE; <span class="comment">// Optional</span></span><br><span class="line">    configInfo.multisampleInfo.alphaToOneEnable = VK_FALSE; <span class="comment">// Optional</span></span><br><span class="line"></span><br><span class="line">    configInfo.colorBlendAttachment.colorWriteMask =</span><br><span class="line">        VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT |</span><br><span class="line">        VK_COLOR_COMPONENT_B_BIT |</span><br><span class="line">        VK_COLOR_COMPONENT_A_BIT;</span><br><span class="line">    configInfo.colorBlendAttachment.blendEnable = VK_FALSE;</span><br><span class="line">    configInfo.colorBlendAttachment.srcColorBlendFactor =</span><br><span class="line">        VK_BLEND_FACTOR_ONE; <span class="comment">// Optional</span></span><br><span class="line">    configInfo.colorBlendAttachment.dstColorBlendFactor =</span><br><span class="line">        VK_BLEND_FACTOR_ZERO; <span class="comment">// Optional</span></span><br><span class="line">    configInfo.colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;</span><br><span class="line">    <span class="comment">// Optional</span></span><br><span class="line">    configInfo.colorBlendAttachment.srcAlphaBlendFactor =</span><br><span class="line">        VK_BLEND_FACTOR_ONE; <span class="comment">// Optional</span></span><br><span class="line">    configInfo.colorBlendAttachment.dstAlphaBlendFactor =</span><br><span class="line">        VK_BLEND_FACTOR_ZERO; <span class="comment">// Optional</span></span><br><span class="line">    configInfo.colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;</span><br><span class="line">    <span class="comment">// Optional</span></span><br><span class="line"></span><br><span class="line">    configInfo.colorBlendInfo.sType =</span><br><span class="line">        VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;</span><br><span class="line">    configInfo.colorBlendInfo.logicOpEnable = VK_FALSE;</span><br><span class="line">    configInfo.colorBlendInfo.logicOp = VK_LOGIC_OP_COPY; <span class="comment">// Optional</span></span><br><span class="line">    configInfo.colorBlendInfo.attachmentCount = <span class="number">1</span>;</span><br><span class="line">    configInfo.colorBlendInfo.pAttachments = &amp;configInfo.</span><br><span class="line">        colorBlendAttachment;</span><br><span class="line">    configInfo.colorBlendInfo.blendConstants[<span class="number">0</span>] = <span class="number">0.0f</span>; <span class="comment">// Optional</span></span><br><span class="line">    configInfo.colorBlendInfo.blendConstants[<span class="number">1</span>] = <span class="number">0.0f</span>; <span class="comment">// Optional</span></span><br><span class="line">    configInfo.colorBlendInfo.blendConstants[<span class="number">2</span>] = <span class="number">0.0f</span>; <span class="comment">// Optional</span></span><br><span class="line">    configInfo.colorBlendInfo.blendConstants[<span class="number">3</span>] = <span class="number">0.0f</span>; <span class="comment">// Optional</span></span><br><span class="line"></span><br><span class="line">    configInfo.depthStencilInfo.sType =</span><br><span class="line">        VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;</span><br><span class="line">    configInfo.depthStencilInfo.depthTestEnable = VK_TRUE;</span><br><span class="line">    configInfo.depthStencilInfo.depthWriteEnable = VK_TRUE;</span><br><span class="line">    configInfo.depthStencilInfo.depthCompareOp = VK_COMPARE_OP_LESS;</span><br><span class="line">    configInfo.depthStencilInfo.depthBoundsTestEnable = VK_FALSE;</span><br><span class="line">    configInfo.depthStencilInfo.minDepthBounds = <span class="number">0.0f</span>; <span class="comment">// Optional</span></span><br><span class="line">    configInfo.depthStencilInfo.maxDepthBounds = <span class="number">1.0f</span>; <span class="comment">// Optional</span></span><br><span class="line">    configInfo.depthStencilInfo.stencilTestEnable = VK_FALSE;</span><br><span class="line">    configInfo.depthStencilInfo.front = &#123;&#125;; <span class="comment">// Optional</span></span><br><span class="line">    configInfo.depthStencilInfo.back = &#123;&#125;; <span class="comment">// Optional</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Vertex-input"><a href="#Vertex-input" class="headerlink" title="Vertex input"></a>Vertex input</h3><p>The <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineVertexInputStateCreateInfo.html"><code>VkPipelineVertexInputStateCreateInfo</code></a> structure describes the format of the vertex data that will be passed to the vertex shader. It describes this in roughly two ways:</p><ul><li>Bindings: spacing between data and whether the data is per-vertex or per-instance (see <a href="https://en.wikipedia.org/wiki/Geometry_instancing">instancing</a>)</li><li>Attribute descriptions: type of the attributes passed to the vertex shader, which binding to load them from and at which offset</li></ul><h2 id="Input-assembly"><a href="#Input-assembly" class="headerlink" title="Input assembly"></a>Input assembly</h2><p>The <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineInputAssemblyStateCreateInfo.html"><code>VkPipelineInputAssemblyStateCreateInfo</code></a> struct describes two things: what kind of geometry will be drawn from the vertices and if primitive restart should be enabled. The former is specified in the <code>topology</code> member and can have values like:</p><ul><li><code>VK_PRIMITIVE_TOPOLOGY_POINT_LIST</code>: points from vertices</li><li><code>VK_PRIMITIVE_TOPOLOGY_LINE_LIST</code>: line from every 2 vertices without reuse</li><li><code>VK_PRIMITIVE_TOPOLOGY_LINE_STRIP</code>: the end vertex of every line is used as start vertex for the next line</li><li><code>VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST</code>: triangle from every 3 vertices without reuse</li><li><code>VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP</code>: the second and third vertex of every triangle are used as first two vertices of the next triangle</li></ul><h2 id="Viewports-and-scissors"><a href="#Viewports-and-scissors" class="headerlink" title="Viewports and scissors"></a>Viewports and scissors</h2><p>A viewport basically describes the region of the framebuffer that the output will be rendered to. This will almost always be <code>(0, 0)</code> to <code>(width, height)</code> and in this tutorial that will also be the case.</p><p>While viewports define the transformation from the image to the framebuffer, scissor rectangles define in which regions pixels will actually be stored. Any pixels outside the scissor rectangles will be discarded by the rasterizer. They function like a filter rather than a transformation. </p><h2 id="Rasterizer"><a href="#Rasterizer" class="headerlink" title="Rasterizer"></a>Rasterizer</h2><p>The rasterizer takes the geometry that is shaped by the vertices from the vertex shader and turns it into fragments to be colored by the fragment shader. It also performs <a href="https://en.wikipedia.org/wiki/Z-buffering">depth testing</a>, <a href="https://en.wikipedia.org/wiki/Back-face_culling">face culling</a> and the scissor test, and it can be configured to output fragments that fill entire polygons or just the edges (wireframe rendering). All this is configured using the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineRasterizationStateCreateInfo.html"><code>VkPipelineRasterizationStateCreateInfo</code></a> structure.</p><h3 id="Multisampling"><a href="#Multisampling" class="headerlink" title="Multisampling"></a>Multisampling</h3><p>The <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineMultisampleStateCreateInfo.html"><code>VkPipelineMultisampleStateCreateInfo</code></a> struct configures multisampling, which is one of the ways to perform <a href="https://en.wikipedia.org/wiki/Multisample_anti-aliasing">anti-aliasing</a>. It works by combining the fragment shader results of multiple polygons that rasterize to the same pixel. This mainly occurs along edges, which is also where the most noticeable aliasing artifacts occur. Because it doesn’t need to run the fragment shader multiple times if only one polygon maps to a pixel, it is significantly less expensive than simply rendering to a higher resolution and then downscaling. Enabling it requires enabling a GPU feature.</p><h3 id="Depth-and-stencil-testing"><a href="#Depth-and-stencil-testing" class="headerlink" title="Depth and stencil testing"></a>Depth and stencil testing</h3><p>If you are using a depth and&#x2F;or stencil buffer, then you also need to configure the depth and stencil tests using <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineDepthStencilStateCreateInfo.html"><code>VkPipelineDepthStencilStateCreateInfo</code></a>.</p><h3 id="Color-blending"><a href="#Color-blending" class="headerlink" title="Color blending"></a>Color blending</h3><p>After a fragment shader has returned a color, it needs to be combined with the color that is already in the framebuffer. This transformation is known as color blending and there are two ways to do it:</p><ul><li>Mix the old and new value to produce a final color</li><li>Combine the old and new value using a bitwise operation.</li></ul><h3 id="Pipeline-layout"><a href="#Pipeline-layout" class="headerlink" title="Pipeline layout"></a>Pipeline layout</h3><p>These uniform values need to be specified during pipeline creation by creating a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineLayout.html"><code>VkPipelineLayout</code></a> object.</p><p>This part is configured in our own application. We will come to this in the future dev logs.</p><h2 id="Create-Shader-Modules"><a href="#Create-Shader-Modules" class="headerlink" title="Create Shader Modules"></a>Create Shader Modules</h2><p>Last time we configured those fixed-function stages, to create a complete pipeline, we still need to create shader modules for vertex shader and fragment shader. My development environment is <strong>Windows11</strong> using <strong>Visual Studio 2022</strong>, the code is simple, but we have to do something else to make it work.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ArkPipeline::CreateShaderModule</span><span class="params">(<span class="keyword">const</span> std::vector&lt;<span class="keyword">char</span>&gt;&amp; code,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     VkShaderModule* shaderModule)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VkShaderModuleCreateInfo createInfo&#123;&#125;;</span><br><span class="line">    createInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;</span><br><span class="line">    createInfo.codeSize = code.<span class="built_in">size</span>();</span><br><span class="line">    createInfo.pCode = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint32_t</span>*&gt;(code.<span class="built_in">data</span>());</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkCreateShaderModule</span>(m_arkDevice.<span class="built_in">Device</span>(), &amp;createInfo, <span class="literal">nullptr</span>,</span><br><span class="line">                             shaderModule) != VK_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create shader module!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We also need a function to read shader file:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="keyword">char</span>&gt; <span class="title">ResourceManager::ReadTextFile</span><span class="params">(<span class="keyword">const</span> std::filesystem::path&amp; path)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// std::ios::ate seek to the end</span></span><br><span class="line">    <span class="function">std::ifstream <span class="title">file</span><span class="params">(path, std::ios::ate | std::ios::binary)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to open file!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> fileSize = <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(file.<span class="built_in">tellg</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">char</span>&gt; <span class="title">buffer</span><span class="params">(fileSize)</span></span>;</span><br><span class="line"></span><br><span class="line">    file.<span class="built_in">seekg</span>(<span class="number">0</span>);</span><br><span class="line">    file.<span class="built_in">read</span>(buffer.<span class="built_in">data</span>(), fileSize);</span><br><span class="line"></span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Unlike earlier APIs, shader code in Vulkan has to be specified in a bytecode format as opposed to human-readable syntax like <a href="https://en.wikipedia.org/wiki/OpenGL_Shading_Language">GLSL</a> and <a href="https://en.wikipedia.org/wiki/High-Level_Shading_Language">HLSL</a>. This bytecode format is called <a href="https://www.khronos.org/spir">SPIR-V</a> and is designed to be used with both Vulkan and OpenCL (both Khronos APIs). It is a format that can be used to write graphics and compute shaders.</p><p>So the shader code we write must be complied into SPIR-V format before we use them, the compilation can be done using <code>glslangValidator.exe</code> or <code>glslc.exe</code>. The advantage of <code>glslc</code> is that it uses the same parameter format as well-known compilers like GCC and Clang and includes some extra functionality like <em>includes</em>. Both of them are already included in the Vulkan SDK.</p><p>In Visual Studio, I created a batch file to build the shaders and run this batch script as a pre-build event. </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> %~dp0..\shaders</span><br><span class="line"><span class="built_in">echo</span> %<span class="built_in">cd</span>%</span><br><span class="line"><span class="keyword">for</span> %%i <span class="keyword">in</span> (*.vert *.frag) <span class="keyword">do</span> ( glslc.exe %%i -o %%i.spv )</span><br></pre></td></tr></table></figure><p>We also need to add the shader files to our project and change their <strong>Item Type</strong> to <strong>Custom Build Tool</strong>. When the contents of the shader files change, they will be compiled automatically.</p><p>Finally change <code>.vcxproj</code> file, add a custom clean command to clean the compiled shader files when we <strong>clean</strong> our project.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Project</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">Target</span> <span class="attr">Name</span>=<span class="string">&quot;CustomClean&quot;</span> <span class="attr">BeforeTargets</span>=<span class="string">&quot;CoreClean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Message</span> <span class="attr">Text</span>=<span class="string">&quot;Clean up compiled spv shaders&quot;</span> <span class="attr">Importance</span>=<span class="string">&quot;high&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">_ShaderFilesToDelete</span> <span class="attr">Include</span>=<span class="string">&quot;$(ProjectDir)shaders\*.spv&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Delete</span> <span class="attr">Files</span>=<span class="string">&quot;@(_ShaderFilesToDelete)&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Target</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">Project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Create-our-pipeline"><a href="#Create-our-pipeline" class="headerlink" title="Create our pipeline"></a>Create our pipeline</h2><p>When creating our pipeline, we mainly focus on the <strong>programmable</strong> stages, in our first simple example, they are <code>vertex shader </code> stage and <code>fragement shader</code> stage.</p><p>The <code>CreateGraphicsPipeline</code> takes in 2 shader paths and 1 <code>PipelineConfigInfo</code>. As the basic configuration has already been defined, the creation is just copying values:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ArkPipeline::CreateGraphicsPipeline</span><span class="params">(<span class="keyword">const</span> std::string&amp; vertShaderPath,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="keyword">const</span> std::string&amp; fragShaderPath,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="keyword">const</span> PipelineConfigInfo&amp;</span></span></span><br><span class="line"><span class="params"><span class="function">                                         configInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(configInfo.pipelineLayout != VK_NULL_HANDLE,</span><br><span class="line">           <span class="string">&quot;Cannot create Graphics pipeline: no pipelineLayout provided in configInfo&quot;</span>);</span><br><span class="line">    <span class="built_in">assert</span>(configInfo.renderPass != VK_NULL_HANDLE,</span><br><span class="line">           <span class="string">&quot;Cannot create Graphics pipeline: no renderPass provided in configInfo&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> vertCode = ResourceManager::<span class="built_in">GetInstance</span>().<span class="built_in">ReadTextFile</span>(</span><br><span class="line">        vertShaderPath);</span><br><span class="line">    <span class="keyword">auto</span> fragCode = ResourceManager::<span class="built_in">GetInstance</span>().<span class="built_in">ReadTextFile</span>(</span><br><span class="line">        fragShaderPath);</span><br><span class="line">    <span class="built_in">CreateShaderModule</span>(vertCode, &amp;m_vertexShaderModule);</span><br><span class="line">    <span class="built_in">CreateShaderModule</span>(fragCode, &amp;m_fragShaderModule);</span><br><span class="line"></span><br><span class="line">    VkPipelineShaderStageCreateInfo shaderStages[<span class="number">2</span>];</span><br><span class="line">    shaderStages[<span class="number">0</span>].sType =</span><br><span class="line">        VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;</span><br><span class="line">    shaderStages[<span class="number">0</span>].stage = VK_SHADER_STAGE_VERTEX_BIT;</span><br><span class="line">    shaderStages[<span class="number">0</span>].<span class="keyword">module</span> = m_vertexShaderModule;</span><br><span class="line">    shaderStages[<span class="number">0</span>].pName = <span class="string">&quot;main&quot;</span>;</span><br><span class="line">    shaderStages[<span class="number">0</span>].flags = <span class="number">0</span>;</span><br><span class="line">    shaderStages[<span class="number">0</span>].pNext = <span class="literal">nullptr</span>;</span><br><span class="line">    shaderStages[<span class="number">0</span>].pSpecializationInfo = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    shaderStages[<span class="number">1</span>].sType =</span><br><span class="line">        VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;</span><br><span class="line">    shaderStages[<span class="number">1</span>].stage = VK_SHADER_STAGE_FRAGMENT_BIT;</span><br><span class="line">    shaderStages[<span class="number">1</span>].<span class="keyword">module</span> = m_fragShaderModule;</span><br><span class="line">    shaderStages[<span class="number">1</span>].pName = <span class="string">&quot;main&quot;</span>;</span><br><span class="line">    shaderStages[<span class="number">1</span>].flags = <span class="number">0</span>;</span><br><span class="line">    shaderStages[<span class="number">1</span>].pNext = <span class="literal">nullptr</span>;</span><br><span class="line">    shaderStages[<span class="number">1</span>].pSpecializationInfo = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> bindingDescriptions = ArkModel::Vertex::<span class="built_in">GetBindingDescriptions</span>();</span><br><span class="line">    <span class="keyword">auto</span> attributeDescriptions =</span><br><span class="line">        ArkModel::Vertex::<span class="built_in">GetAttributeDescriptions</span>();</span><br><span class="line">    VkPipelineVertexInputStateCreateInfo vertexInputInfo&#123;&#125;;</span><br><span class="line">    vertexInputInfo.sType =</span><br><span class="line">        VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;</span><br><span class="line">    vertexInputInfo.vertexAttributeDescriptionCount = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(</span><br><span class="line">        attributeDescriptions.<span class="built_in">size</span>());</span><br><span class="line">    vertexInputInfo.vertexBindingDescriptionCount = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(</span><br><span class="line">        bindingDescriptions.<span class="built_in">size</span>());</span><br><span class="line">    vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions.</span><br><span class="line">        <span class="built_in">data</span>();</span><br><span class="line">    vertexInputInfo.pVertexBindingDescriptions = bindingDescriptions.<span class="built_in">data</span>();</span><br><span class="line">    VkGraphicsPipelineCreateInfo pipelineInfo&#123;&#125;;</span><br><span class="line">    pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;</span><br><span class="line">    pipelineInfo.stageCount = <span class="number">2</span>;</span><br><span class="line">    pipelineInfo.pStages = shaderStages;</span><br><span class="line">    pipelineInfo.pVertexInputState = &amp;vertexInputInfo;</span><br><span class="line">    pipelineInfo.pInputAssemblyState = &amp;configInfo.inputAssemblyInfo;</span><br><span class="line">    pipelineInfo.pMultisampleState = &amp;configInfo.multisampleInfo;</span><br><span class="line">    pipelineInfo.pViewportState = &amp;configInfo.viewportInfo;</span><br><span class="line">    pipelineInfo.pRasterizationState = &amp;configInfo.rasterizationInfo;</span><br><span class="line">    pipelineInfo.pColorBlendState = &amp;configInfo.colorBlendInfo;</span><br><span class="line">    pipelineInfo.pDynamicState = <span class="literal">nullptr</span>;</span><br><span class="line">    pipelineInfo.pDepthStencilState = &amp;configInfo.depthStencilInfo;</span><br><span class="line"></span><br><span class="line">    pipelineInfo.pDynamicState = &amp;configInfo.dynamicStateInfo;</span><br><span class="line"></span><br><span class="line">    pipelineInfo.layout = configInfo.pipelineLayout;</span><br><span class="line">    pipelineInfo.renderPass = configInfo.renderPass;</span><br><span class="line">    pipelineInfo.subpass = configInfo.subpass;</span><br><span class="line"></span><br><span class="line">    pipelineInfo.basePipelineIndex = <span class="number">-1</span>;</span><br><span class="line">    pipelineInfo.basePipelineHandle = VK_NULL_HANDLE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkCreateGraphicsPipelines</span>(m_arkDevice.<span class="built_in">Device</span>(), VK_NULL_HANDLE, <span class="number">1</span>,</span><br><span class="line">                                  &amp;pipelineInfo, <span class="literal">nullptr</span>,</span><br><span class="line">                                  &amp;m_graphicsPipeline) != VK_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create graphics pipeline!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;The-ArkPipeline&quot;&gt;&lt;a href=&quot;#The-ArkPipeline&quot; class=&quot;headerlink&quot; title=&quot;The ArkPipeline&quot;&gt;&lt;/a&gt;The &lt;code&gt;ArkPipeline&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;Next </summary>
      
    
    
    
    <category term="computer graphics" scheme="https://proton991.github.io/categories/computer-graphics/"/>
    
    
    <category term="Renderer" scheme="https://proton991.github.io/tags/Renderer/"/>
    
    <category term="Vulkan" scheme="https://proton991.github.io/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>Ark VkRenderer Dev Log 3</title>
    <link href="https://proton991.github.io/Ark-VkRenderer-Dev-Log-3/"/>
    <id>https://proton991.github.io/Ark-VkRenderer-Dev-Log-3/</id>
    <published>2022-07-05T02:45:22.000Z</published>
    <updated>2022-07-25T12:06:29.455Z</updated>
    
    <content type="html"><![CDATA[<h1 id="The-ArkSwapChain"><a href="#The-ArkSwapChain" class="headerlink" title="The ArkSwapChain"></a>The <code>ArkSwapChain</code></h1><p>Now we are going to build another important component of our engine, the <code>ArkSwapChain</code>.</p><h2 id="Window-Surface"><a href="#Window-Surface" class="headerlink" title="Window Surface"></a>Window Surface</h2><p>The object to which graphics data is rendered in order to be presented is known as a surface and is<br>represented by a <code>VkSurfaceKHR</code> handle. This special object is introduced by the <code>VK_KHR_surface</code> extension.  We are using GLFW to handle our windows, so we will use <code>glfwCreateWindowSurface</code> to create our window surface, here’s the function’s prototype:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">glfwCreateWindowSurface</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkInstance instance,</span></span></span><br><span class="line"><span class="params"><span class="function">    GLFWwindow* window,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> VkAllocationCallbacks* allocator,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkSurfaceKHR* surface </span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><p>So we must pass in a <code>VkInstance</code> to create a surface, that’s why we store its handle and implement its functionality in our <code>ArkDevice</code> class.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">VkSurfaceKHR m_surface;</span><br><span class="line">WindowSystem&amp; m_window;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ArkDevice::CreateSurface</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_window.<span class="built_in">CreateWindowSurface</span>(m_instance, &amp;m_surface);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WindowSystem::CreateWindowSurface</span><span class="params">(VkInstance instance,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       VkSurfaceKHR* surface)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwCreateWindowSurface</span>(instance, m_window, <span class="literal">nullptr</span>, surface) !=</span><br><span class="line">        VK_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create window surface!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Swap-chain"><a href="#Swap-chain" class="headerlink" title="Swap chain"></a>Swap chain</h2><p>Regardless of which platform you’re running on, the resulting <code>VkSurfaceKHR</code> handle refers to<br>Vulkan’s view of a window. In order to actually present anything to that surface, it’s necessary to<br>create a special image that can be used to store the data in the window. On most platforms, this type<br>of image is either owned by or tightly integrated with the window system, so rather than creating a<br>normal Vulkan image object, we use a second object called a swap chain to manage one or more<br>image objects.<br>Swap-chain objects are used to ask the native window system to create one or more images that can<br>be used to present into a Vulkan surface. This is exposed using the VK_KHR_swapchain<br>extension. Each swap-chain object manages a set of images, usually in some form of ring buffer. The<br>application can ask the swap chain for the next available image, render into it, and then hand the<br>image back to the swap chain ready for display. By managing presentable images in a ring or queue,<br>one image can be presented to the display while another is being drawn to by the application,<br>overlapping the operation of the window system and application.<br>To create a swap-chain object, call <code>vkCreateSwapchainKHR()</code>,</p><p>The code related to swap chain will be in <code>ArkSwapChain.hpp</code> &amp; <code>ArkSwapChain.cpp</code>.</p><h3 id="Check-for-swap-chain-support"><a href="#Check-for-swap-chain-support" class="headerlink" title="Check for swap chain support"></a>Check for swap chain support</h3><p>Now we are going to touch another important concepts in Vulkan, <em>swap chain</em>. </p><p>Before using it, we need to check its extension support, this has already been done when we pick our physical device. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> std::vector&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; deviceExtensions = &#123;</span><br><span class="line">    VK_KHR_SWAPCHAIN_EXTENSION_NAME</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ArkDevice::CheckDeviceExtensionSupport</span><span class="params">(VkPhysicalDevice device)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> extensionCount;</span><br><span class="line">    <span class="built_in">vkEnumerateDeviceExtensionProperties</span>(device, <span class="literal">nullptr</span>, &amp;extensionCount,</span><br><span class="line">                                         <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;VkExtensionProperties&gt; <span class="title">availableExtensions</span><span class="params">(extensionCount)</span></span>;</span><br><span class="line">    <span class="built_in">vkEnumerateDeviceExtensionProperties</span>(</span><br><span class="line">        device,</span><br><span class="line">        <span class="literal">nullptr</span>,</span><br><span class="line">        &amp;extensionCount,</span><br><span class="line">        availableExtensions.<span class="built_in">data</span>());</span><br><span class="line"></span><br><span class="line">    <span class="function">std::set&lt;std::string&gt; <span class="title">requiredExtensions</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        deviceExtensions.begin(), deviceExtensions.end())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; extension : availableExtensions)</span><br><span class="line">    &#123;</span><br><span class="line">        requiredExtensions.<span class="built_in">erase</span>(extension.extensionName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> requiredExtensions.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>When creating logical device, enable the extension:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateLogicalDevice</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    createInfo.enabledExtensionCount = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(</span><br><span class="line">        deviceExtensions.<span class="built_in">size</span>());</span><br><span class="line">    createInfo.ppEnabledExtensionNames = deviceExtensions.<span class="built_in">data</span>();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Querying-details-of-swap-chain-support"><a href="#Querying-details-of-swap-chain-support" class="headerlink" title="Querying details of swap chain support"></a>Querying details of swap chain support</h3><p>Just checking if a swap chain is available is not sufficient, because it may not actually be compatible with our window surface. Creating a swap chain also involves a lot more settings than instance and device creation, so we need to query for some more details before we’re able to proceed.</p><p>There are basically three kinds of properties we need to check:</p><ul><li>Basic surface capabilities (min&#x2F;max number of images in swap chain, min&#x2F;max width and height of images)</li><li>Surface formats (pixel format, color space)</li><li>Available presentation modes</li></ul><p>Similar to <code>QueueFamilyIndices</code>, we put these properties in a struct:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SwapChainSupportDetails</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VkSurfaceCapabilitiesKHR m_capabilities;</span><br><span class="line">    std::vector&lt;VkSurfaceFormatKHR&gt; m_formats;</span><br><span class="line">    std::vector&lt;VkPresentModeKHR&gt; m_presentModes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>We need a function to populate this struct:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SwapChainSupportDetails <span class="title">ArkDevice::QuerySwapChainSupport</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkPhysicalDevice device)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SwapChainSupportDetails details;</span><br><span class="line">    <span class="built_in">vkGetPhysicalDeviceSurfaceCapabilitiesKHR</span>(</span><br><span class="line">        device, m_surface, &amp;details.m_capabilities);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> formatCount;</span><br><span class="line">    <span class="built_in">vkGetPhysicalDeviceSurfaceFormatsKHR</span>(device, m_surface, &amp;formatCount,</span><br><span class="line">                                         <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (formatCount != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        details.m_formats.<span class="built_in">resize</span>(formatCount);</span><br><span class="line">        <span class="built_in">vkGetPhysicalDeviceSurfaceFormatsKHR</span>(</span><br><span class="line">            device, m_surface, &amp;formatCount, details.m_formats.<span class="built_in">data</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> presentModeCount;</span><br><span class="line">    <span class="built_in">vkGetPhysicalDeviceSurfacePresentModesKHR</span>(</span><br><span class="line">        device, m_surface, &amp;presentModeCount, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (presentModeCount != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        details.m_presentModes.<span class="built_in">resize</span>(presentModeCount);</span><br><span class="line">        <span class="built_in">vkGetPhysicalDeviceSurfacePresentModesKHR</span>(</span><br><span class="line">            device,</span><br><span class="line">            m_surface,</span><br><span class="line">            &amp;presentModeCount,</span><br><span class="line">            details.m_presentModes.<span class="built_in">data</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> details;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Choose-the-right-swap-chain"><a href="#Choose-the-right-swap-chain" class="headerlink" title="Choose the right swap chain"></a>Choose the right swap chain</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Helper functions</span></span><br><span class="line"><span class="function">VkSurfaceFormatKHR <span class="title">ChooseSwapSurfaceFormat</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> std::vector&lt;VkSurfaceFormatKHR&gt;&amp; availableFormats)</span></span>;</span><br><span class="line"><span class="function">VkPresentModeKHR <span class="title">ChooseSwapPresentMode</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> std::vector&lt;VkPresentModeKHR&gt;&amp; availablePresentModes)</span></span>;</span><br><span class="line"><span class="function">VkExtent2D <span class="title">ChooseSwapExtent</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> VkSurfaceCapabilitiesKHR&amp; capabilities)</span></span>;</span><br></pre></td></tr></table></figure><p>After creating swap chain, we need to use class members to store some handles for later use:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VkSwapchainKHR m_swapChain;</span><br><span class="line">std::vector&lt;VkImage&gt; m_swapChainImages;</span><br><span class="line">VkFormat m_swapChainImageFormat;</span><br><span class="line">VkExtent2D m_windowExtent;</span><br></pre></td></tr></table></figure><p>The images were created by the implementation for the swap chain and they will be automatically cleaned up once the swap chain has been destroyed, therefore we don’t need to add any cleanup code.</p><h2 id="Image-views"><a href="#Image-views" class="headerlink" title="Image views"></a>Image views</h2><p><code>VkImageView</code> objects are created based on the <code>VkImage</code> objects that are retrieved after we create swap chain.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ArkSwapChain::CreateImageViews</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_swapChainImageViews.<span class="built_in">resize</span>(m_swapChainImages.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; m_swapChainImages.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        VkImageViewCreateInfo viewInfo&#123;&#125;;</span><br><span class="line">        viewInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;</span><br><span class="line">        viewInfo.image = m_swapChainImages[i];</span><br><span class="line">        viewInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;</span><br><span class="line">        viewInfo.format = m_swapChainImageFormat;</span><br><span class="line">        viewInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;</span><br><span class="line">        viewInfo.subresourceRange.baseMipLevel = <span class="number">0</span>;</span><br><span class="line">        viewInfo.subresourceRange.levelCount = <span class="number">1</span>;</span><br><span class="line">        viewInfo.subresourceRange.baseArrayLayer = <span class="number">0</span>;</span><br><span class="line">        viewInfo.subresourceRange.layerCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">vkCreateImageView</span>(m_device.<span class="built_in">Device</span>(), &amp;viewInfo, <span class="literal">nullptr</span>,</span><br><span class="line">                              &amp;m_swapChainImageViews[i]) !=</span><br><span class="line">            VK_SUCCESS)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(</span><br><span class="line">                <span class="string">&quot;failed to create texture image view!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Unlike images, the image views were explicitly created by us, so we need to add a similar loop to destroy them again at the end of the program:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> imageView : m_swapChainImageViews)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vkDestroyImageView</span>(m_device.<span class="built_in">Device</span>(), imageView, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Create-Render-Pass"><a href="#Create-Render-Pass" class="headerlink" title="Create Render Pass"></a>Create Render Pass</h2><p>Now it’s time to create render pass. Before we can finish creating the pipeline, we need to tell Vulkan about the framebuffer attachments that will be used while rendering. We need to specify how many color and depth buffers there will be, how many samples to use for each of them and how their contents should be handled throughout the rendering operations. All of this information is wrapped in a <em><strong>render pass</strong></em> object. </p><p>When creating render pass, we need to set its <em>attachments</em>. For now, we need to set depth attachment and color attachment:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">VkAttachmentDescription depthAttachment&#123;&#125;;</span><br><span class="line">depthAttachment.format = <span class="built_in">FindDepthFormat</span>();</span><br><span class="line">depthAttachment.samples = VK_SAMPLE_COUNT_1_BIT;</span><br><span class="line">depthAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;</span><br><span class="line">depthAttachment.storeOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;</span><br><span class="line">depthAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;</span><br><span class="line">depthAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;</span><br><span class="line">depthAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;</span><br><span class="line">depthAttachment.finalLayout =</span><br><span class="line">    VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;</span><br><span class="line"></span><br><span class="line">VkAttachmentReference depthAttachmentRef&#123;&#125;;</span><br><span class="line">depthAttachmentRef.attachment = <span class="number">1</span>;</span><br><span class="line">depthAttachmentRef.layout =</span><br><span class="line">    VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;</span><br><span class="line"></span><br><span class="line">VkAttachmentDescription colorAttachment = &#123;&#125;;</span><br><span class="line">colorAttachment.format = <span class="built_in">GetSwapChainImageFormat</span>();</span><br><span class="line">colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT;</span><br><span class="line">colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;</span><br><span class="line">colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE;</span><br><span class="line">colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;</span><br><span class="line">colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;</span><br><span class="line">colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;</span><br><span class="line">colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;</span><br><span class="line"></span><br><span class="line">VkAttachmentReference colorAttachmentRef = &#123;&#125;;</span><br><span class="line">colorAttachmentRef.attachment = <span class="number">0</span>;</span><br><span class="line">colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;</span><br></pre></td></tr></table></figure><p>Note that we also created <em>attachment reference</em>, they are used for our <strong>subpasses</strong>. </p><p>A single render pass can consist of multiple <strong>subpasses</strong>. <strong>Subpasses</strong> are subsequent rendering operations that depend on the contents of framebuffers in previous passes, for example a sequence of post-processing effects that are applied one after another. If you group these rendering operations into one render pass, then Vulkan is able to reorder the operations and conserve memory bandwidth for possibly better performance.</p><p>Every subpass references one or more of the attachments that we’ve described using the structure in the previous sections. </p><p>Finally, create our render pass:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">VkRenderPassCreateInfo renderPassInfo = &#123;&#125;;</span><br><span class="line">renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;</span><br><span class="line">renderPassInfo.attachmentCount = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(attachments.</span><br><span class="line">                                                       <span class="built_in">size</span>());</span><br><span class="line">renderPassInfo.pAttachments = attachments.<span class="built_in">data</span>();</span><br><span class="line">renderPassInfo.subpassCount = <span class="number">1</span>;</span><br><span class="line">renderPassInfo.pSubpasses = &amp;subpass;</span><br><span class="line">renderPassInfo.dependencyCount = <span class="number">1</span>;</span><br><span class="line">renderPassInfo.pDependencies = &amp;dependency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">vkCreateRenderPass</span>(m_arkDevice.<span class="built_in">Device</span>(), &amp;renderPassInfo, <span class="literal">nullptr</span>,</span><br><span class="line">                       &amp;m_renderPass) != VK_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create render pass!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Create-Frame-Buffers"><a href="#Create-Frame-Buffers" class="headerlink" title="Create Frame Buffers"></a>Create Frame Buffers</h2><p>The attachments specified during render pass creation are bound by wrapping them into a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkFramebuffer.html"><code>VkFramebuffer</code></a> object. A framebuffer object references all of the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkImageView.html"><code>VkImageView</code></a> objects that represent the attachments. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ArkSwapChain::CreateFrameBuffers</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_swapChainFrameBuffers.<span class="built_in">resize</span>(<span class="built_in">ImageCount</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="built_in">ImageCount</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::array&lt;VkImageView, 2&gt; attachments = &#123;</span><br><span class="line">            m_swapChainImageViews[i], m_depthImageViews[i]</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        VkExtent2D swapChainExtent = <span class="built_in">GetSwapChainExtent</span>();</span><br><span class="line">        VkFramebufferCreateInfo framebufferInfo = &#123;&#125;;</span><br><span class="line">        framebufferInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;</span><br><span class="line">        framebufferInfo.renderPass = m_renderPass;</span><br><span class="line">        framebufferInfo.attachmentCount = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(attachments.</span><br><span class="line">                                                                <span class="built_in">size</span>());</span><br><span class="line">        framebufferInfo.pAttachments = attachments.<span class="built_in">data</span>();</span><br><span class="line">        framebufferInfo.width = swapChainExtent.width;</span><br><span class="line">        framebufferInfo.height = swapChainExtent.height;</span><br><span class="line">        framebufferInfo.layers = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">vkCreateFramebuffer</span>(</span><br><span class="line">            m_arkDevice.<span class="built_in">Device</span>(),</span><br><span class="line">            &amp;framebufferInfo,</span><br><span class="line">            <span class="literal">nullptr</span>,</span><br><span class="line">            &amp;m_swapChainFrameBuffers[i]) != VK_SUCCESS)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create framebuffer!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>m_depthImageViews</code> are created in the <code>CreateDepthResources()</code> function, which are attached to frame buffers. </p><h2 id="Putting-them-together"><a href="#Putting-them-together" class="headerlink" title="Putting them together"></a>Putting them together</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ArkSwapChain::Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">CreateSwapChain</span>();</span><br><span class="line">    <span class="built_in">CreateImageViews</span>();</span><br><span class="line">    <span class="built_in">CreateRenderPass</span>();</span><br><span class="line">    <span class="built_in">CreateDepthResources</span>();</span><br><span class="line">    <span class="built_in">CreateFrameBuffers</span>();</span><br><span class="line">    <span class="built_in">CreateSyncObjects</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The following graph illustrates their relationship:</p><p><img src="/Ark-VkRenderer-Dev-Log-3/1.png" alt="Explanation"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;The-ArkSwapChain&quot;&gt;&lt;a href=&quot;#The-ArkSwapChain&quot; class=&quot;headerlink&quot; title=&quot;The ArkSwapChain&quot;&gt;&lt;/a&gt;The &lt;code&gt;ArkSwapChain&lt;/code&gt;&lt;/h1&gt;&lt;p&gt;N</summary>
      
    
    
    
    <category term="computer graphics" scheme="https://proton991.github.io/categories/computer-graphics/"/>
    
    
    <category term="Renderer" scheme="https://proton991.github.io/tags/Renderer/"/>
    
    <category term="Vulkan" scheme="https://proton991.github.io/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>Ark VkRenderer Dev Log 2</title>
    <link href="https://proton991.github.io/Ark-VkRenderer-Dev-Log-2/"/>
    <id>https://proton991.github.io/Ark-VkRenderer-Dev-Log-2/</id>
    <published>2022-07-05T01:03:54.000Z</published>
    <updated>2022-07-14T03:40:00.585Z</updated>
    
    <content type="html"><![CDATA[<h1 id="The-ArkDevice-cont"><a href="#The-ArkDevice-cont" class="headerlink" title="The ArkDevice cont."></a>The <code>ArkDevice</code> cont.</h1><h2 id="Logical-device-and-queues"><a href="#Logical-device-and-queues" class="headerlink" title="Logical device and queues"></a>Logical device and queues</h2><p>After selecting a physical device to use we need to set up a <em>logical device</em> to interface with it. The logical device creation process is similar to the instance creation process and describes the features we want to use. We also need to specify which queues to create now that we’ve queried which queue families are available. </p><p>The creation process involves specifying a bunch of details in structs. The first one is <code>VkDeviceQueueCreateInfo</code>. This structure describes the number of queues we want for a single queue family, The<code> QueueFamily</code> is found by <code>FindQueueFamilies</code>, which is shown in last dev log.  Then using a while loop to set each <code>VkDeviceQueueCreateInfo</code> separately.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> queuePriority = <span class="number">1.0f</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">uint32_t</span> queueFamily : uniqueQueueFamilies)</span><br><span class="line">&#123;</span><br><span class="line">    VkDeviceQueueCreateInfo queueCreateInfo = &#123;&#125;;</span><br><span class="line">    queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;</span><br><span class="line">    queueCreateInfo.queueFamilyIndex = queueFamily;</span><br><span class="line">    queueCreateInfo.queueCount = <span class="number">1</span>;</span><br><span class="line">    queueCreateInfo.pQueuePriorities = &amp;queuePriority;</span><br><span class="line">    queueCreateInfos.<span class="built_in">push_back</span>(queueCreateInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We make sure that queue families requirement are satisfied when we pick our physical device, then we attach the queue create  info to the logical device.</p><p>Next, we specify used device features:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VkPhysicalDeviceFeatures deviceFeatures = &#123;&#125;;</span><br><span class="line">deviceFeatures.samplerAnisotropy = VK_TRUE;</span><br></pre></td></tr></table></figure><p>Here enabling <code>samplerAnisotropy</code> means enhancing the image quality of textures on surfaces through anisotropic filtering (abbreviated AF).</p><p>Finally, we can create our logical device, create a <code>VkDeviceCreateInfo</code> struct and fill in data.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">VkDeviceCreateInfo createInfo = &#123;&#125;;</span><br><span class="line">createInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;</span><br><span class="line"></span><br><span class="line">createInfo.queueCreateInfoCount = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(queueCreateInfos</span><br><span class="line">                                                        .<span class="built_in">size</span>());</span><br><span class="line">createInfo.pQueueCreateInfos = queueCreateInfos.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">createInfo.pEnabledFeatures = &amp;deviceFeatures;</span><br><span class="line">createInfo.enabledExtensionCount = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(</span><br><span class="line">    deviceExtensions.<span class="built_in">size</span>());</span><br><span class="line">createInfo.ppEnabledExtensionNames = deviceExtensions.<span class="built_in">data</span>();</span><br></pre></td></tr></table></figure><p>The last step to specify validation layers in already deprecated, but we still add this for compatibility reasons:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// might not really be necessary anymore because device specific validation layers</span></span><br><span class="line"><span class="comment">// have been deprecated</span></span><br><span class="line"><span class="keyword">if</span> (enableValidationLayers)</span><br><span class="line">&#123;</span><br><span class="line">    createInfo.enabledLayerCount = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(</span><br><span class="line">        validationLayers.<span class="built_in">size</span>());</span><br><span class="line">    createInfo.ppEnabledLayerNames = validationLayers.<span class="built_in">data</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    createInfo.enabledLayerCount = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now we are ready to create our logical device:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">vkCreateDevice</span>(m_physicalDevice, &amp;createInfo, <span class="literal">nullptr</span>, &amp;m_device) !=</span><br><span class="line">    VK_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create logical device!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>There’s one more thing to do. The queues are automatically created along with the logical device, but we don’t have a handle to interface with them yet. Add a a class member to store a handle to the graphics queue:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vkGetDeviceQueue</span>(m_device, indices.m_graphicsFamily, <span class="number">0</span>, &amp;m_graphicsQueue);</span><br></pre></td></tr></table></figure><p>Remember to destroy the device before we exit the program,</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vkDestroyDevice</span>(device, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><h2 id="Window-surface-and-presentation-queue"><a href="#Window-surface-and-presentation-queue" class="headerlink" title="Window surface and presentation queue"></a>Window surface and presentation queue</h2><p> To establish the connection between Vulkan and the window system to present results to the screen, we need to use the WSI (Window System Integration) extensions.  Here we will use <code>VkSurfaceKHR</code>. We create this surface in our <code>WindowSystem</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WindowSystem::CreateWindowSurface</span><span class="params">(VkInstance instance,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       VkSurfaceKHR* surface)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">glfwCreateWindowSurface</span>(instance, m_window, <span class="literal">nullptr</span>, surface) !=</span><br><span class="line">        VK_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create window surface!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Next, we need to query for presentation support, modify <code>IsDeviceSuitable</code> to check both graphics queue and presentation queue support, modify <code>FindQueueFamilies</code> to get presentation support using <code>vkGetPhysicalDeviceSurfaceSupportKHR</code>.</p><h2 id="Command-buffers"><a href="#Command-buffers" class="headerlink" title="Command buffers"></a>Command buffers</h2><p>There’s still one thing left in our <code>ArkDeivce</code>, the command pool <code>VkCommandPool m_commandPool;</code></p><p>Commands in Vulkan, like drawing operations and memory transfers, are not executed directly using function calls. We have to record all of the operations we want to perform in command buffer objects. </p><p>The advantage of this is that when we are ready to tell the Vulkan what we want to do, all of the commands are submitted together and Vulkan can more efficiently process the commands since all of them are available together. In addition, this allows command recording to happen in multiple threads if so desired.</p><h2 id="Command-Pools"><a href="#Command-Pools" class="headerlink" title="Command Pools"></a>Command Pools</h2><p>We have to create a command pool before we can create command buffers. Command pools manage the memory that is used to store the buffers and command buffers are allocated from them.  Add a member variable in our <code>ArkDevice</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VkCommandPool m_commandPool;</span><br></pre></td></tr></table></figure><p>To create a command pool, we need to set its family index and flags:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ArkDevice::CreateCommandPool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QueueFamilyIndices queueFamilyIndices = <span class="built_in">FindPhysicalQueueFamilies</span>();</span><br><span class="line"></span><br><span class="line">    VkCommandPoolCreateInfo poolInfo = &#123;&#125;;</span><br><span class="line">    poolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;</span><br><span class="line">    poolInfo.queueFamilyIndex = queueFamilyIndices.m_graphicsFamily;</span><br><span class="line">    poolInfo.flags =</span><br><span class="line">        VK_COMMAND_POOL_CREATE_TRANSIENT_BIT |</span><br><span class="line">        VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkCreateCommandPool</span>(m_device, &amp;poolInfo, <span class="literal">nullptr</span>, &amp;m_commandPool) !=</span><br><span class="line">        VK_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create command pool!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>There are two possible flags for command pools:</p><ul><li><code>VK_COMMAND_POOL_CREATE_TRANSIENT_BIT</code>: Hint that command buffers are rerecorded with new commands very often (may change memory allocation behavior)</li><li><code>VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT</code>: Allow command buffers to be rerecorded individually, without this flag they all have to be reset together</li></ul><p>We will be recording a command buffer every frame, so we want to be able to reset and rerecord over it. Thus, we need to set the <code>VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT</code> flag bit for our command pool.</p><p>Don’ t forget to destroy it:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vkDestroyCommandPool</span>(m_device, m_commandPool, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><h2 id="Command-Buffers"><a href="#Command-Buffers" class="headerlink" title="Command Buffers"></a>Command Buffers</h2><p>Command buffers will be handled by <code>ArkRenderer</code> class, as we will record our command every frame.  Creating a command buffer is simple:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ArkRenderer::CreateCommandBuffers</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_commandBuffers.<span class="built_in">resize</span>(ArkSwapChain::MAX_FRAMES_IN_FLIGHT);</span><br><span class="line">    VkCommandBufferAllocateInfo allocateInfo&#123;&#125;;</span><br><span class="line">    allocateInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;</span><br><span class="line">    allocateInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;</span><br><span class="line">    allocateInfo.commandPool = m_arkDevice.<span class="built_in">GetCommandPool</span>();</span><br><span class="line">    allocateInfo.commandBufferCount = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(m_commandBuffers</span><br><span class="line">                                                            .<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkAllocateCommandBuffers</span>(m_arkDevice.<span class="built_in">Device</span>(), &amp;allocateInfo,</span><br><span class="line">                                 m_commandBuffers.<span class="built_in">data</span>()) != VK_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to allocate command buffers!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>So how to record our commands? Buffers are associated with frames, so in our <code>ArkRenderer</code>, we begin recording our commands when we begin our frame and end our recording when we end our frame. The whole process comes in 2 parts in <code>ArkRenderer</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VkCommandBuffer <span class="title">ArkRenderer::BeginFrame</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(</span><br><span class="line">        !m_isFrameStarted &amp;&amp;</span><br><span class="line">        <span class="string">&quot;Can&#x27;t call BeginFrame() while already in progress&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> result = m_arkSwapChain-&gt;<span class="built_in">AcquireNextImage</span>(&amp;m_imageIndex);</span><br><span class="line">    <span class="keyword">if</span> (result == VK_ERROR_OUT_OF_DATE_KHR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">RecreateSwapChain</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result != VK_SUCCESS &amp;&amp; result != VK_SUBOPTIMAL_KHR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to acquire swap chain image!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    m_isFrameStarted = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">auto</span> commandBuffer = <span class="built_in">GetCurrentCommandBuffer</span>();</span><br><span class="line">    VkCommandBufferBeginInfo beginInfo&#123;&#125;;</span><br><span class="line">    beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkBeginCommandBuffer</span>(commandBuffer, &amp;beginInfo) !=</span><br><span class="line">        VK_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(</span><br><span class="line">            <span class="string">&quot;failed to begin recording command buffers!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> commandBuffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ArkRenderer::EndFrame</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(</span><br><span class="line">        m_isFrameStarted &amp;&amp;</span><br><span class="line">        <span class="string">&quot;Can&#x27;t call EndFrame() while frame is not in progress&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> commandBuffer = <span class="built_in">GetCurrentCommandBuffer</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkEndCommandBuffer</span>(commandBuffer) != VK_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to record command buffer!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> result = m_arkSwapChain-&gt;<span class="built_in">SubmitCommandBuffers</span>(</span><br><span class="line">        &amp;commandBuffer, &amp;m_imageIndex);</span><br><span class="line">    <span class="keyword">if</span> (result == VK_ERROR_OUT_OF_DATE_KHR || result == VK_SUBOPTIMAL_KHR ||</span><br><span class="line">        m_window.<span class="built_in">WasWindowResized</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        m_window.<span class="built_in">ResetWindowResizedFlag</span>();</span><br><span class="line">        <span class="built_in">RecreateSwapChain</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (result != VK_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to represent swap chain image!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    m_isFrameStarted = <span class="literal">false</span>;</span><br><span class="line">    m_frameIndex = (m_frameIndex + <span class="number">1</span>) % ArkSwapChain::MAX_FRAMES_IN_FLIGHT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Notice there’s something about swap chain, which will be covered in the coming dev logs! </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;The-ArkDevice-cont&quot;&gt;&lt;a href=&quot;#The-ArkDevice-cont&quot; class=&quot;headerlink&quot; title=&quot;The ArkDevice cont.&quot;&gt;&lt;/a&gt;The &lt;code&gt;ArkDevice&lt;/code&gt; cont</summary>
      
    
    
    
    <category term="computer graphics" scheme="https://proton991.github.io/categories/computer-graphics/"/>
    
    
    <category term="Renderer" scheme="https://proton991.github.io/tags/Renderer/"/>
    
    <category term="Vulkan" scheme="https://proton991.github.io/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>Ark VkRenderer Dev Log 1</title>
    <link href="https://proton991.github.io/Ark-VkRenderer-Dev-Log-1/"/>
    <id>https://proton991.github.io/Ark-VkRenderer-Dev-Log-1/</id>
    <published>2022-07-04T04:25:25.000Z</published>
    <updated>2022-07-14T02:12:33.505Z</updated>
    
    <content type="html"><![CDATA[<h1 id="The-ArkDevice"><a href="#The-ArkDevice" class="headerlink" title="The ArkDevice"></a>The <code>ArkDevice</code></h1><p><code>ArkDevice</code> is neither equal to <code>VkDevice</code>  or <code>VkPhysicalDevice</code>, it is an encapsulation of several key components in Vulkan. First let’s take a look at its member variables:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">VkInstance m_instance;</span><br><span class="line">VkDebugUtilsMessengerEXT m_debugMessenger;</span><br><span class="line">VkPhysicalDevice m_physicalDevice = VK_NULL_HANDLE;</span><br><span class="line">WindowSystem&amp; m_window;</span><br><span class="line">VkCommandPool m_commandPool;</span><br><span class="line"></span><br><span class="line">VkDevice m_device;</span><br><span class="line">VkSurfaceKHR m_surface;</span><br><span class="line">VkQueue m_graphicsQueue;</span><br><span class="line">VkQueue m_presentQueue;</span><br></pre></td></tr></table></figure><p>And constants:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> std::vector&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; validationLayers = &#123;</span><br><span class="line">    <span class="string">&quot;VK_LAYER_KHRONOS_validation&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> std::vector&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; deviceExtensions = &#123;</span><br><span class="line">    VK_KHR_SWAPCHAIN_EXTENSION_NAME</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Enabling-Validation-Layer"><a href="#Enabling-Validation-Layer" class="headerlink" title="Enabling Validation Layer"></a>Enabling Validation Layer</h2><p>Creating a <code>VkInstance</code> in Vulkan is the very first thing we need to do when we use Vulkan library, so we need to store its handle in <code>m_instance</code>. We also need <strong>Validation layer</strong> for error checking. This layer can do following things:</p><ul><li>Checking the values of parameters against the specification to detect misuse</li><li>Tracking creation and destruction of objects to find resource leaks</li><li>Checking thread safety by tracking the threads that calls originate from</li><li>Logging every call and its parameters to the standard output</li><li>Tracing Vulkan calls for profiling and replaying</li></ul><p>Before enabling it, we need to check whether they are supported:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ArkDevice::CheckValidationLayerSupport</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> layerCount;</span><br><span class="line">    <span class="built_in">vkEnumerateInstanceLayerProperties</span>(&amp;layerCount, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;VkLayerProperties&gt; <span class="title">availableLayers</span><span class="params">(layerCount)</span></span>;</span><br><span class="line">    <span class="built_in">vkEnumerateInstanceLayerProperties</span>(&amp;layerCount, availableLayers.<span class="built_in">data</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span>* layerName : validationLayers)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> layerFound = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; layerProperties : availableLayers)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(layerName, layerProperties.layerName) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                layerFound = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!layerFound)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We also need to enable relevant extensions when creating our instance:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; <span class="title">ArkDevice::GetRequiredExtensions</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> glfwExtensionCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>** glfwExtensions;</span><br><span class="line">    glfwExtensions = <span class="built_in">glfwGetRequiredInstanceExtensions</span>(&amp;glfwExtensionCount);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; <span class="title">extensions</span><span class="params">(glfwExtensions,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        glfwExtensions +</span></span></span><br><span class="line"><span class="params"><span class="function">                                        glfwExtensionCount)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enableValidationLayers)</span><br><span class="line">    &#123;</span><br><span class="line">        extensions.<span class="built_in">push_back</span>(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> extensions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The validation layers will print debug messages to the standard output by default, but we can also handle them ourselves by providing an explicit callback in our program. This will also allow you to decide which kind of messages you would like to see, because not all are necessarily (fatal) errors, this is done by setting up a <strong>callback</strong> function:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// local callback functions</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> VKAPI_ATTR VkBool32 VKAPI_CALL <span class="title">debugCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDebugUtilsMessageTypeFlagsEXT messageType,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> VkDebugUtilsMessengerCallbackDataEXT* pCallbackData,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">void</span>* pUserData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;validation layer: &quot;</span> &lt;&lt; pCallbackData-&gt;pMessage &lt;&lt;</span><br><span class="line">        std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> VK_FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In this function we can filter the message output based on our preference. </p><p>The debug callback is also managed with a handle that needs to be explicitly created and destroyed. This part of work is left for programmers, so we need to store a member variable:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VkDebugUtilsMessengerEXT m_debugMessenger;</span><br></pre></td></tr></table></figure><p><code>VkDebugUtilsMessengerEXT </code> is associated with an instance, so we call our <code>SetupDebugMessenger</code> after we create our instance:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ArkDevice::SetupDebugMessenger</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!enableValidationLayers) <span class="keyword">return</span>;</span><br><span class="line">    VkDebugUtilsMessengerCreateInfoEXT createInfo;</span><br><span class="line">    <span class="built_in">PopulateDebugMessengerCreateInfo</span>(createInfo);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CreateDebugUtilsMessengerEXT</span>(m_instance, &amp;createInfo, <span class="literal">nullptr</span>,</span><br><span class="line">                                     &amp;m_debugMessenger) != VK_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to set up debug messenger!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">VkResult <span class="title">CreateDebugUtilsMessengerEXT</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkInstance instance,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> VkAllocationCallbacks* pAllocator,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDebugUtilsMessengerEXT* pDebugMessenger)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> func = (PFN_vkCreateDebugUtilsMessengerEXT)<span class="built_in">vkGetInstanceProcAddr</span>(</span><br><span class="line">        instance,</span><br><span class="line">        <span class="string">&quot;vkCreateDebugUtilsMessengerEXT&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (func != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">func</span>(instance, pCreateInfo, pAllocator, pDebugMessenger);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> VK_ERROR_EXTENSION_NOT_PRESENT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ArkDevice::PopulateDebugMessengerCreateInfo</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDebugUtilsMessengerCreateInfoEXT&amp; createInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    createInfo = &#123;&#125;;</span><br><span class="line">    createInfo.sType =</span><br><span class="line">        VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;</span><br><span class="line">    createInfo.messageSeverity =</span><br><span class="line">        VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT |</span><br><span class="line">        VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;</span><br><span class="line">    createInfo.messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT |</span><br><span class="line">        VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT |</span><br><span class="line">        VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;</span><br><span class="line">    createInfo.pfnUserCallback = debugCallback;</span><br><span class="line">    createInfo.pUserData = <span class="literal">nullptr</span>; <span class="comment">// Optional</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>To create a <code>VkDebugUtilsMessengerEXT </code>, we should use <code>vkCreateDebugUtilsMessengerEXT</code> function,  Unfortunately, because this function is an extension function, it is not automatically loaded. We have to look up its address ourselves using <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkGetInstanceProcAddr.html"><code>vkGetInstanceProcAddr</code></a>. </p><p>BUT there’s one more thing to do, we are not able to debug any issues in when we create our instance and destroy it, because the messenger has to be created after we create our instance and destroyed before destroying instance. Don’t worry, there is a way to create a separate debug utils messenger specifically for those two function calls.</p><p>t requires you to simply pass a pointer to a <code>VkDebugUtilsMessengerCreateInfoEXT</code> struct in the <code>pNext</code> extension field of <code>VkInstanceCreateInfo</code>.  When we create our instance, we can call our <code>PopulateDebugMessengerCreateInfo</code> to set up debug messenger for our instance:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (enableValidationLayers)</span><br><span class="line">    &#123;</span><br><span class="line">        createInfo.enabledLayerCount = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(</span><br><span class="line">            validationLayers.<span class="built_in">size</span>());</span><br><span class="line">        createInfo.ppEnabledLayerNames = validationLayers.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">PopulateDebugMessengerCreateInfo</span>(debugCreateInfo);</span><br><span class="line">        createInfo.pNext = (VkDebugUtilsMessengerCreateInfoEXT*)&amp;</span><br><span class="line">            debugCreateInfo;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="Select-Physical-device"><a href="#Select-Physical-device" class="headerlink" title="Select Physical device"></a>Select Physical device</h2><p>After creating <code>VkInstance</code> we need to select a graphics card, the process is quite straightforwad:</p><ol><li>Get all the physical devices that we have.</li><li>Check one by one and find the suitable one.</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ArkDevice::PickPhysicalDevice</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> deviceCount = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vkEnumeratePhysicalDevices</span>(m_instance, &amp;deviceCount, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (deviceCount == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(</span><br><span class="line">            <span class="string">&quot;failed to find GPUs with Vulkan support!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Device count: &quot;</span> &lt;&lt; deviceCount &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">std::vector&lt;VkPhysicalDevice&gt; <span class="title">devices</span><span class="params">(deviceCount)</span></span>;</span><br><span class="line">    <span class="built_in">vkEnumeratePhysicalDevices</span>(m_instance, &amp;deviceCount, devices.<span class="built_in">data</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; device : devices)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">IsDeviceSuitable</span>(device))</span><br><span class="line">        &#123;</span><br><span class="line">            m_physicalDevice = device;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_physicalDevice == VK_NULL_HANDLE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to find a suitable GPU!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vkGetPhysicalDeviceProperties</span>(m_physicalDevice, &amp;properties);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;physical device: &quot;</span> &lt;&lt; properties.deviceName &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Base-device-suitability-checks"><a href="#Base-device-suitability-checks" class="headerlink" title="Base device suitability checks"></a>Base device suitability checks</h3><p>Here, ‘suitable’ means to check their supported extensions, their properties, their features… (Such as checking whether it supports Raytracing), here’s our <code>IsDeviceSuitable</code> function:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> std::vector&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; deviceExtensions = &#123;</span><br><span class="line">    VK_KHR_SWAPCHAIN_EXTENSION_NAME</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ArkDevice::CheckDeviceExtensionSupport</span><span class="params">(VkPhysicalDevice device)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> extensionCount;</span><br><span class="line">    <span class="built_in">vkEnumerateDeviceExtensionProperties</span>(device, <span class="literal">nullptr</span>, &amp;extensionCount,</span><br><span class="line">                                         <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="function">std::vector&lt;VkExtensionProperties&gt; <span class="title">availableExtensions</span><span class="params">(extensionCount)</span></span>;</span><br><span class="line">    <span class="built_in">vkEnumerateDeviceExtensionProperties</span>(</span><br><span class="line">        device,</span><br><span class="line">        <span class="literal">nullptr</span>,</span><br><span class="line">        &amp;extensionCount,</span><br><span class="line">        availableExtensions.<span class="built_in">data</span>());</span><br><span class="line"></span><br><span class="line">    <span class="function">std::set&lt;std::string&gt; <span class="title">requiredExtensions</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        deviceExtensions.begin(), deviceExtensions.end())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; extension : availableExtensions)</span><br><span class="line">    &#123;</span><br><span class="line">        requiredExtensions.<span class="built_in">erase</span>(extension.extensionName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> requiredExtensions.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ArkDevice::IsDeviceSuitable</span><span class="params">(VkPhysicalDevice device)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QueueFamilyIndices indices = <span class="built_in">FindQueueFamilies</span>(device);</span><br><span class="line">    VkPhysicalDeviceProperties deviceProperties;</span><br><span class="line">    <span class="built_in">vkGetPhysicalDeviceProperties</span>(device, &amp;deviceProperties);</span><br><span class="line">    <span class="keyword">if</span> (deviceProperties.deviceType != VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> extensionsSupported = <span class="built_in">CheckDeviceExtensionSupport</span>(device);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> swapChainAdequate = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (extensionsSupported)</span><br><span class="line">    &#123;</span><br><span class="line">        SwapChainSupportDetails swapChainSupport = <span class="built_in">QuerySwapChainSupport</span>(</span><br><span class="line">            device);</span><br><span class="line">        swapChainAdequate = !swapChainSupport.m_formats.<span class="built_in">empty</span>() &amp;&amp; !</span><br><span class="line">            swapChainSupport.m_presentModes.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    VkPhysicalDeviceFeatures supportedFeatures;</span><br><span class="line">    <span class="built_in">vkGetPhysicalDeviceFeatures</span>(device, &amp;supportedFeatures);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> indices.<span class="built_in">IsComplete</span>() &amp;&amp; extensionsSupported &amp;&amp; swapChainAdequate</span><br><span class="line">        &amp;&amp;</span><br><span class="line">        supportedFeatures.samplerAnisotropy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Queue-families"><a href="#Queue-families" class="headerlink" title="Queue families"></a>Queue families</h3><p>Almost every operation in Vulkan, anything from drawing to uploading textures, requires commands to be submitted to a queue. There are different types of queues that originate from different <em>queue families</em> and each family of queues allows only a subset of commands. For example, there could be a queue family that only allows processing of compute commands or one that only allows memory transfer related commands. We need to check which queue families are supported by the device and which one of these supports the commands that we want to use. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QueueFamilyIndices</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> m_graphicsFamily;</span><br><span class="line">    <span class="keyword">uint32_t</span> m_presentFamily;</span><br><span class="line">    <span class="keyword">bool</span> m_graphicsFamilyHasValue = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> m_presentFamilyHasValue = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsComplete</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_graphicsFamilyHasValue &amp;&amp; m_presentFamilyHasValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Here’s how we find a physical device’s queue family:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QueueFamilyIndices <span class="title">ArkDevice::FindQueueFamilies</span><span class="params">(VkPhysicalDevice device)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QueueFamilyIndices indices;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> queueFamilyCount = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vkGetPhysicalDeviceQueueFamilyProperties</span>(</span><br><span class="line">        device, &amp;queueFamilyCount, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;VkQueueFamilyProperties&gt; <span class="title">queueFamilies</span><span class="params">(queueFamilyCount)</span></span>;</span><br><span class="line">    <span class="built_in">vkGetPhysicalDeviceQueueFamilyProperties</span>(</span><br><span class="line">        device, &amp;queueFamilyCount, queueFamilies.<span class="built_in">data</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; queueFamily : queueFamilies)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (queueFamily.queueCount &gt; <span class="number">0</span> &amp;&amp; queueFamily.queueFlags &amp;</span><br><span class="line">            VK_QUEUE_GRAPHICS_BIT)</span><br><span class="line">        &#123;</span><br><span class="line">            indices.m_graphicsFamily = i;</span><br><span class="line">            indices.m_graphicsFamilyHasValue = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        VkBool32 presentSupport = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">vkGetPhysicalDeviceSurfaceSupportKHR</span>(</span><br><span class="line">            device, i, m_surface, &amp;presentSupport);</span><br><span class="line">        <span class="keyword">if</span> (queueFamily.queueCount &gt; <span class="number">0</span> &amp;&amp; presentSupport)</span><br><span class="line">        &#123;</span><br><span class="line">            indices.m_presentFamily = i;</span><br><span class="line">            indices.m_presentFamilyHasValue = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (indices.<span class="built_in">IsComplete</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> indices;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The way we find our required queue families is calling <code>vkGetPhysicalDeviceQueueFamilyProperties</code> twice, then we need to find at least one queue family that supports <code>VK_QUEUE_GRAPHICS_BIT</code>.  Here we also  need to do some work to find find one queue family for Surface support(we will cover this topic later).</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;The-ArkDevice&quot;&gt;&lt;a href=&quot;#The-ArkDevice&quot; class=&quot;headerlink&quot; title=&quot;The ArkDevice&quot;&gt;&lt;/a&gt;The &lt;code&gt;ArkDevice&lt;/code&gt;&lt;/h1&gt;&lt;p&gt;&lt;code&gt;ArkDevi</summary>
      
    
    
    
    <category term="computer graphics" scheme="https://proton991.github.io/categories/computer-graphics/"/>
    
    
    <category term="Renderer" scheme="https://proton991.github.io/tags/Renderer/"/>
    
    <category term="Vulkan" scheme="https://proton991.github.io/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>Ark VkRenderer Dev Log 0</title>
    <link href="https://proton991.github.io/Ark-VkRender-Dev-Log-0/"/>
    <id>https://proton991.github.io/Ark-VkRender-Dev-Log-0/</id>
    <published>2022-07-03T09:21:10.000Z</published>
    <updated>2022-07-14T01:17:07.235Z</updated>
    
    <content type="html"><![CDATA[<h2 id="VkRenderer-from-scratch"><a href="#VkRenderer-from-scratch" class="headerlink" title="VkRenderer from scratch"></a><code>VkRenderer</code> from scratch</h2><p>This renderer is based on a <a href="https://www.youtube.com/playlist?list=PL8327DO66nu9qYVKLDmdLW_84-yE4auCR">tutorial</a> on youtube (which itself is based on <a href="https://vulkan-tutorial.com/">https://vulkan-tutorial.com/</a>). My plan is to finish this in <strong>1</strong> month. <strong>Vulkan</strong> is a new API that I never used before, so I will explain the main concepts in detail along the way in order to fully understand it. For the theory part I will reference another serial on youtube - <a href="https://www.youtube.com/playlist?list=PLmIqTlJ6KsE1Jx5HV4sd2jOe3V1KMHHgn">Vulkan Essentials</a>. </p><h2 id="About-Vulkan"><a href="#About-Vulkan" class="headerlink" title="About Vulkan"></a>About Vulkan</h2><p>Vulkan has the following features:</p><ul><li>Graphics <strong>and</strong> compute API</li><li>Cross-platform and cross-device</li><li>High efficiency and low level</li><li>explicit (verbose) API</li></ul><p>Major Vulkan handles:</p><ul><li>Vulkan instance: <code>VkInstance</code></li><li>Physical device: <code>VkPhysicalDevice</code></li><li>Logical device: <code>VkDevice</code></li></ul><p>Vulkan Extensions 2 types:</p><ol><li>Instance Extensions: Debug features, OS-specific features, Cross-device&#x2F;instance&#x2F;process memory</li><li>Device extensions: Capabilities of a physical device(RTX&#x2F;GTX)</li></ol><p>functions with <strong>EXT</strong> suffix, e.g. <code>vkCreateDebugUtilsMessengerEXT()</code></p><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>Our <strong>FIRST GOAL</strong> is to draw a triangle, so how?</p><p>The answer is roughly about <strong>8</strong> steps in total:</p><ol><li>Instance and physical device selection</li><li>Logical device and queue families.</li><li>Window surface and swap chain.</li><li>Image views and framebuffers.</li><li>Render passes.</li><li>Graphics pipeline.</li><li>Command pools and command buffers.</li><li>Main loop.</li></ol><p><u>This is the routine provided by <a href="https://vulkan-tutorial.com/">Vulkan Tutorial</a>, but the output of this tutorial is a ‘huge’ source file containing all the ‘messy’ code. Though Vulkan is a ‘verbose’ API that requires us to make everything explicit, there’s still some ‘components’ that can be reused. So after following the Vulkan game engine on YouTube for a while. I decided to rewrite the dev log.</u></p><h2 id="First-of-all-a-window"><a href="#First-of-all-a-window" class="headerlink" title="First of all, a window"></a>First of all, a window</h2><p>We will use <code>GLFW</code> as our window API, so first thing todo is to build a <strong>WindowSystem</strong>, I have done something similar in another OpenGL based renderer, so I will simply paste the code here.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GLFW_INCLUDE_VULKAN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Ark</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WindowSystem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> m_width;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> m_height;</span><br><span class="line"></span><br><span class="line">        std::string m_windowName;</span><br><span class="line">        GLFWwindow* m_window;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">WindowSystem</span>(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">const</span> std::string&amp; name);</span><br><span class="line">        ~<span class="built_in">WindowSystem</span>();</span><br><span class="line">        <span class="built_in">WindowSystem</span>(WindowSystem&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">        <span class="comment">// Disable copying</span></span><br><span class="line">        <span class="built_in">WindowSystem</span>(<span class="keyword">const</span> WindowSystem&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">        WindowSystem&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> WindowSystem&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">ShouldClose</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">glfwWindowShouldClose</span>(m_window); &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>And its implementation:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;WindowSystem.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Ark</span><br><span class="line">&#123;</span><br><span class="line">    WindowSystem::<span class="built_in">WindowSystem</span>(<span class="keyword">const</span> <span class="keyword">int</span> w, <span class="keyword">const</span> <span class="keyword">int</span> h,</span><br><span class="line">                               <span class="keyword">const</span> std::string&amp; name) :</span><br><span class="line">        <span class="built_in">m_width</span>(w), <span class="built_in">m_height</span>(h), <span class="built_in">m_windowName</span>(name)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Init</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">WindowSystem::Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">glfwInit</span>();</span><br><span class="line">        <span class="built_in">glfwWindowHint</span>(GLFW_CLIENT_API, GLFW_NO_API);</span><br><span class="line">        <span class="built_in">glfwWindowHint</span>(GLFW_RESIZABLE, GLFW_FALSE);</span><br><span class="line">        m_window = <span class="built_in">glfwCreateWindow</span>(m_width, m_height, m_windowName.<span class="built_in">c_str</span>(),</span><br><span class="line">                                    <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WindowSystem::~<span class="built_in">WindowSystem</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glfwDestroyWindow</span>(m_window);</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">WindowSystem::CreateWindowSurface</span><span class="params">(VkInstance instance,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       VkSurfaceKHR* surface)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">glfwCreateWindowSurface</span>(instance, m_window, <span class="literal">nullptr</span>, surface) !=</span><br><span class="line">            VK_SUCCESS)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create window surface!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We will not get involved with window resizing or input handling when drawing our first triangle, so these functions are enough for us.</p><h2 id="Let’s-create-an-instance"><a href="#Let’s-create-an-instance" class="headerlink" title="Let’s create an instance"></a>Let’s create an instance</h2><p>A <code>VkInstance</code> is an object that connects your application with Vulkan library. This is the very first thing we need to do. The way we use Vulkan APIs is different from OpenGL. In OpenGL we pass information through function parameters, while in Vulkan we pass them through <em>structs</em>. </p><p>To create a <code>vkInstance</code>, we need 2 structs, <code>VkApplicationInfo</code> &amp; <code>VkInstanceCreateInfo</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ArkDevice::CreateInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VkApplicationInfo appInfo = &#123;&#125;;</span><br><span class="line">    appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;</span><br><span class="line">    appInfo.pApplicationName = <span class="string">&quot;LittleVulkanEngine App&quot;</span>;</span><br><span class="line">    appInfo.applicationVersion = <span class="built_in">VK_MAKE_VERSION</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    appInfo.pEngineName = <span class="string">&quot;No Engine&quot;</span>;</span><br><span class="line">    appInfo.engineVersion = <span class="built_in">VK_MAKE_VERSION</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    appInfo.apiVersion = VK_API_VERSION_1_0;</span><br><span class="line"></span><br><span class="line">    VkInstanceCreateInfo createInfo = &#123;&#125;;</span><br><span class="line">    createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;</span><br><span class="line">    createInfo.pApplicationInfo = &amp;appInfo;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkCreateInstance</span>(&amp;createInfo, <span class="literal">nullptr</span>, &amp;m_instance) != VK_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create m_instance!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>To create an instance, we also need to configure <strong>extensions</strong>, we need to specify the desired global extensions before creating them. Vulkan is a platform agnostic API, so we need an extension to interface with the window system. The function we need is <code>glfwGetRequiredInstanceExtensions</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; <span class="title">ArkDevice::GetRequiredExtensions</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> glfwExtensionCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>** glfwExtensions;</span><br><span class="line">    glfwExtensions = <span class="built_in">glfwGetRequiredInstanceExtensions</span>(&amp;glfwExtensionCount);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; <span class="title">extensions</span><span class="params">(glfwExtensions,</span></span></span><br><span class="line"><span class="params"><span class="function">    glfwExtensions +</span></span></span><br><span class="line"><span class="params"><span class="function">    glfwExtensionCount)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enableValidationLayers)</span><br><span class="line">    &#123;</span><br><span class="line">    extensions.<span class="built_in">push_back</span>(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> extensions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>And we use <code>vkEnumerateInstanceExtensionProperties</code> to check available extensions before creating instance:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ArkDevice::HasGlfwRequiredInstanceExtensions</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> extensionCount = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vkEnumerateInstanceExtensionProperties</span>(<span class="literal">nullptr</span>, &amp;extensionCount,</span><br><span class="line">                                           <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="function">std::vector&lt;VkExtensionProperties&gt; <span class="title">extensions</span><span class="params">(extensionCount)</span></span>;</span><br><span class="line">    <span class="built_in">vkEnumerateInstanceExtensionProperties</span>(<span class="literal">nullptr</span>, &amp;extensionCount,</span><br><span class="line">                                           extensions.<span class="built_in">data</span>());</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;available extensions:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::unordered_set&lt;std::string&gt; available;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; extension : extensions)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; extension.extensionName &lt;&lt; std::endl;</span><br><span class="line">        available.<span class="built_in">insert</span>(extension.extensionName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;required extensions:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">auto</span> requiredExtensions = <span class="built_in">GetRequiredExtensions</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; required : requiredExtensions)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; required &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">if</span> (available.<span class="built_in">find</span>(required) == available.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Missing required glfw extension&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We can see the pattern when we use API like <code>vkEnumerateXXX()</code>:</p><ul><li>call  <code>vkEnumerateXXX()</code> to get the <strong>number</strong> of <code>XXX</code>.</li><li>call  <code>vkEnumerateXXX()</code> again to get the <strong>data</strong> of <code>XXX</code>.</li></ul><p>Finally, don’t forget to call <code>vkDestroyInstance()</code> before the program exits.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;VkRenderer-from-scratch&quot;&gt;&lt;a href=&quot;#VkRenderer-from-scratch&quot; class=&quot;headerlink&quot; title=&quot;VkRenderer from scratch&quot;&gt;&lt;/a&gt;&lt;code&gt;VkRenderer&lt;</summary>
      
    
    
    
    <category term="computer graphics" scheme="https://proton991.github.io/categories/computer-graphics/"/>
    
    
    <category term="Renderer" scheme="https://proton991.github.io/tags/Renderer/"/>
    
    <category term="Vulkan" scheme="https://proton991.github.io/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>ArkRenderer Dev Log 1</title>
    <link href="https://proton991.github.io/ArkRenderer-Dev-Log-1/"/>
    <id>https://proton991.github.io/ArkRenderer-Dev-Log-1/</id>
    <published>2022-06-22T10:38:31.000Z</published>
    <updated>2022-06-22T14:16:01.467Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Wrapping-Vertex-Array-Object-amp-Vertex-Buffer-Object"><a href="#Wrapping-Vertex-Array-Object-amp-Vertex-Buffer-Object" class="headerlink" title="Wrapping Vertex Array Object &amp; Vertex Buffer Object"></a>Wrapping Vertex Array Object &amp; Vertex Buffer Object</h2><p>To start drawing something we have to first give OpenGL some input vertex data. These data are stored in GPU memory, which are managed via so called <strong>vertex buffer objects(VBO)</strong>.</p><p><strong>A Vertex Array Object (or VAO)</strong> is an object that <strong>describes how the vertex attributes are stored in a Vertex Buffer Object (or VBO)</strong></p><p>Using such objects in OpenGL follows the pattern “Gen..&#x2F;Bind…&#x2F;..Enable(use)”, similar to a state machine. So we use OOP to wrap them together to make our code cleaner and improve readability.</p><p>A vertex attribute is <strong>an input variable to a shader that is supplied with per-vertex data</strong>. These variable can contain, for example, positions, normals or texture coordinates.</p><p>We use <code>GLVertexArray</code> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GLVertexArray.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GLVertexArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">BufferType</span> :</span> <span class="keyword">int</span></span><br><span class="line">    &#123;</span><br><span class="line">        Array = GL_ARRAY_BUFFER,</span><br><span class="line">        Element = GL_ELEMENT_ARRAY_BUFFER</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">DrawMode</span> :</span> <span class="keyword">int</span></span><br><span class="line">    &#123;</span><br><span class="line">        Static = GL_STATIC_DRAW,</span><br><span class="line">        Dynamic = GL_DYNAMIC_DRAW,</span><br><span class="line">        Stream = GL_STREAM_DRAW</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AttachBuffer</span><span class="params">(<span class="keyword">const</span> BufferType type, <span class="keyword">const</span> <span class="keyword">size_t</span> size,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="keyword">const</span> DrawMode mode, <span class="keyword">const</span> <span class="keyword">void</span>* data)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Bind</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">EnableAttribute</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> index, <span class="keyword">const</span> <span class="keyword">int</span> size,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> offset, <span class="keyword">const</span> <span class="keyword">void</span>* data)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> m_vao&#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// GLVertexArray.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;GLVertexArray.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GLVertexArray::Init</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;m_vao);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GLVertexArray::AttachBuffer</span><span class="params">(<span class="keyword">const</span> BufferType type, <span class="keyword">const</span> <span class="keyword">size_t</span> size,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="keyword">const</span> DrawMode mode, <span class="keyword">const</span> <span class="keyword">void</span>* data)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> buffer;</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(type, buffer);</span><br><span class="line">    <span class="built_in">glBufferData</span>(type, size, data, mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GLVertexArray::Bind</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(m_vao);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GLVertexArray::Delete</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glDeleteVertexArrays</span>(<span class="number">1</span>, &amp;m_vao);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GLVertexArray::EnableAttribute</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> index, <span class="keyword">const</span> <span class="keyword">int</span> size,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> offset,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="keyword">const</span> <span class="keyword">void</span>* data)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(index);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(index, size, GL_FLOAT, GL_FALSE, offset, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="Shader-Classes"><a href="#Shader-Classes" class="headerlink" title="Shader Classes"></a>Shader Classes</h2><p><strong>Shaders</strong> are little programs that rest on the GPU, which are run for each specific section of the graphics pipeline.</p><p>Below is the OpenGL rendering pipeline. There are many stages, each stage takes in input data and output data for next stage.</p><p><img src="/ArkRenderer-Dev-Log-1/RenderingPipeline.png" alt="RenderingPipeline"></p><p>At the beginning, we will only use <strong>vertex shader</strong> and <strong>fragment shader</strong>. We use a <code>ShaderStage</code> struct to store each shader stage:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Graphics</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> std::unordered_map&lt;std::string, <span class="keyword">int</span>&gt; TYPE2_GL_ENUM&#123;</span><br><span class="line">        &#123;<span class="string">&quot;vertex&quot;</span>, GL_VERTEX_SHADER&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;fragment&quot;</span>, GL_FRAGMENT_SHADER&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;geometry&quot;</span>, GL_GEOMETRY_SHADER&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;compute&quot;</span>, GL_COMPUTE_SHADER&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ShaderStage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="built_in">ShaderStage</span>() <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ShaderStage</span>(<span class="keyword">const</span> std::string&amp; path, <span class="keyword">const</span> std::string&amp; type) :</span><br><span class="line">            <span class="built_in">m_filePath</span>(path), <span class="built_in">m_type</span>(type)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::string m_filePath;</span><br><span class="line">        std::string m_type;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;; <span class="comment">// namespace Graphics</span></span><br></pre></td></tr></table></figure><p>We manipulate shaders via id, which is the return value of <code>glCreateShader()</code>.  Uniform variables allow us to pass data to our shaders, the difference between attribute and uniform variable is that attribute variables contain data which is vertex specific so they are reloaded with a new value from the vertex buffer for each shader invocation while the value of uniform variables remains constant across the entire draw call. Here’s how we define a Shader program:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GLShaderProgram</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unordered_map&lt;std::string, <span class="keyword">int</span>&gt; m_uniforms;</span><br><span class="line">    GLuint m_programId&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    std::string m_programName;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GetUniforms</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GLShaderProgram</span>(<span class="keyword">const</span> std::string&amp; programName, <span class="keyword">const</span> GLuint programId);</span><br><span class="line">    ~<span class="built_in">GLShaderProgram</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Bind</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DeleteProgram</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">GLShaderProgram&amp; <span class="title">SetUniformi</span><span class="params">(<span class="keyword">const</span> std::string&amp; uniformName,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">const</span> <span class="keyword">int</span> value)</span></span>;</span><br><span class="line">    <span class="function">GLShaderProgram&amp; <span class="title">SetUniformf</span><span class="params">(<span class="keyword">const</span> std::string&amp; uniformName,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">const</span> <span class="keyword">float</span> value)</span></span>;</span><br><span class="line">    <span class="function">GLShaderProgram&amp; <span class="title">SetUniform</span><span class="params">(<span class="keyword">const</span> std::string&amp; uniformName,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">const</span> glm::ivec2&amp; value)</span></span>;</span><br><span class="line">    <span class="function">GLShaderProgram&amp; <span class="title">SetUniform</span><span class="params">(<span class="keyword">const</span> std::string&amp; uniformName,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">const</span> glm::vec2&amp; value)</span></span>;</span><br><span class="line">    <span class="function">GLShaderProgram&amp; <span class="title">SetUniform</span><span class="params">(<span class="keyword">const</span> std::string&amp; uniformName,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">const</span> glm::vec3&amp; value)</span></span>;</span><br><span class="line">    <span class="function">GLShaderProgram&amp; <span class="title">SetUniform</span><span class="params">(<span class="keyword">const</span> std::string&amp; uniformName,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">const</span> glm::vec4&amp; value)</span></span>;</span><br><span class="line">    <span class="function">GLShaderProgram&amp; <span class="title">SetUniform</span><span class="params">(<span class="keyword">const</span> std::string&amp; uniformName,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">const</span> glm::mat3x3&amp; value)</span></span>;</span><br><span class="line">    <span class="function">GLShaderProgram&amp; <span class="title">SetUniform</span><span class="params">(<span class="keyword">const</span> std::string&amp; uniformName,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">const</span> glm::mat4x4&amp; value)</span></span>;</span><br><span class="line"></span><br><span class="line">    [[nodiscard]] <span class="function"><span class="keyword">auto</span> <span class="title">GetProgramName</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> m_programName; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">GLShaderProgram::<span class="built_in">GLShaderProgram</span>(<span class="keyword">const</span> std::string&amp; programName,</span><br><span class="line">                                 <span class="keyword">const</span> GLuint programID):</span><br><span class="line">    <span class="built_in">m_programId</span>(programID), <span class="built_in">m_programName</span>(programName)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GetUniforms</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GLShaderProgram::GetUniforms</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">glGetProgramiv</span>(m_programId, GL_ACTIVE_UNIFORMS, &amp;total);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; total; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> nameLen = <span class="number">-1</span>, num = <span class="number">-1</span>;</span><br><span class="line">        GLenum type = GL_ZERO;</span><br><span class="line">        <span class="keyword">char</span> name[<span class="number">100</span>];</span><br><span class="line">        <span class="built_in">glGetActiveUniform</span>(m_programId, <span class="keyword">static_cast</span>&lt;GLuint&gt;(i),</span><br><span class="line">                           <span class="built_in"><span class="keyword">sizeof</span></span>(name) - <span class="number">1</span>, &amp;nameLen, &amp;num, &amp;type, name);</span><br><span class="line">        name[nameLen] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> nameStr = std::<span class="built_in">string</span>(name);</span><br><span class="line">        m_uniforms.<span class="built_in">try_emplace</span>(nameStr,</span><br><span class="line">                               <span class="built_in">glGetUniformLocation</span>(m_programId, name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We use <strong>factory pattern</strong> to create shaders, <code>GLShaderProgramFactory</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GLShaderProgramFactory.h</span></span><br><span class="line"><span class="keyword">namespace</span> Graphics</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">GLShaderProgramFactory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">static</span> std::optional&lt;GLShaderProgram&gt; <span class="title">CreateShaderProgram</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">const</span> std::string&amp; programName,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">const</span> std::vector&lt;ShaderStage&gt;&amp; stages</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;; <span class="comment">// namespace Graphics</span></span><br></pre></td></tr></table></figure><p>Here’s the implementation of <code>CreateShaderProgram</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::optional&lt;GLShaderProgram&gt; <span class="title">GLShaderProgramFactory::CreateShaderProgram</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">const</span> std::string&amp; programName, <span class="keyword">const</span> std::vector&lt;ShaderStage&gt;&amp; stages)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Building shader program &quot;</span> &lt;&lt; programName &lt;&lt; std::endl;</span><br><span class="line">    std::vector&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; shaderIds;</span><br><span class="line">    <span class="keyword">bool</span> success = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; stage : stages)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> id = <span class="built_in">glCreateShader</span>(TYPE2_GL_ENUM.<span class="built_in">at</span>(stage.m_type));</span><br><span class="line">        shaderIds.<span class="built_in">push_back</span>(id);</span><br><span class="line">        <span class="keyword">auto</span> shaderCode&#123; ResourceManager::<span class="built_in">GetInstance</span>().<span class="built_in">LoadTextFile</span>(stage.m_filePath) &#125;;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">CompileStage</span>(id, shaderCode, stage.m_type))</span><br><span class="line">        &#123;</span><br><span class="line">            success = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!success)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Shader Compilation failed\n&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> id : shaderIds)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">glDeleteShader</span>(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> std::nullopt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> programId = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> id : shaderIds)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glAttachShader</span>(programId, id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">LinkProgram</span>(programId) || !<span class="built_in">ValidateProgram</span>(programId))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> id : shaderIds)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">glDetachShader</span>(programId, id);</span><br><span class="line">            <span class="built_in">glDeleteShader</span>(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">glDeleteProgram</span>(programId);</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Shader Link failed\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> std::nullopt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> id : shaderIds) &#123;</span><br><span class="line">        <span class="built_in">glDetachShader</span>(programId, id);</span><br><span class="line">        <span class="built_in">glDeleteShader</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> std::make_optional&lt;GLShaderProgram&gt;(&#123; programName, programId &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The whole process is straightforward:</p><ol><li>Load shader source code.</li><li>Compile shader and check errors.</li><li>Attach shader and link program.</li><li>Delete the shaders as they’re linked into our program now and no longer necessary.</li></ol><p>That’s all for today! Next we will dive into model and meshes!.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Wrapping-Vertex-Array-Object-amp-Vertex-Buffer-Object&quot;&gt;&lt;a href=&quot;#Wrapping-Vertex-Array-Object-amp-Vertex-Buffer-Object&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="computer graphics" scheme="https://proton991.github.io/categories/computer-graphics/"/>
    
    
    <category term="Renderer" scheme="https://proton991.github.io/tags/Renderer/"/>
    
    <category term="OpenGL" scheme="https://proton991.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>ArkRenderer Dev Log 0</title>
    <link href="https://proton991.github.io/ArkRenderer-Dev-Log-0/"/>
    <id>https://proton991.github.io/ArkRenderer-Dev-Log-0/</id>
    <published>2022-06-17T09:32:03.000Z</published>
    <updated>2022-06-17T12:30:58.301Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Window-System"><a href="#Window-System" class="headerlink" title="Window System"></a>Window System</h2><p>Lot’s of OpenGL tutorials start with teaching people to create a black window. To create windows, we need <a href="glfw.org">GLFW</a>, which provides a simple API for creating windows, contexts and surfaces, receiving input and events. Integrating 3rd party libraries in Visual Studio can be done in many ways, I prefer this way:</p><ol><li>building lib file from source code</li><li>set include and library directories </li><li>link libs.</li></ol><p>Step 2 &amp; 3 are done by setting properties of the project.</p><p>A windows has many properties that can be configured, such as position, size, but as a starting point, we will not make it that complex. (I will improve it by reading configuration file and set these value). So a basic Window System should be something like this:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GLFWwindow</span>;</span><span class="comment">// use forward declaration</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WindowSystem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WindowSystem</span>() <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">WindowSystem</span>(WindowSystem&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    WindowSystem&amp; <span class="keyword">operator</span>=(WindowSystem&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">WindowSystem</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Shutdown</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Disable Copying</span></span><br><span class="line">    <span class="built_in">WindowSystem</span>(<span class="keyword">const</span> WindowSystem&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    WindowSystem&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> WindowSystem&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function">GLFWwindow* <span class="title">Init</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SwapBuffers</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    [[nodiscard]] <span class="function"><span class="keyword">bool</span> <span class="title">IsCursorVisible</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_showCursor;</span><br><span class="line">    &#125;</span><br><span class="line">    [[nodiscard]] <span class="function"><span class="keyword">bool</span> <span class="title">ShouldClose</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_shouldClose;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Shutdown</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    GLFWwindow* m_window&#123; <span class="literal">nullptr</span> &#125;;</span><br><span class="line">    <span class="keyword">bool</span> m_showCursor&#123; <span class="literal">false</span> &#125;;</span><br><span class="line">    <span class="keyword">bool</span> m_shouldClose&#123; <span class="literal">false</span> &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Let’s take a look at the <code>Init()</code> function:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GLFWwindow* <span class="title">WindowSystem::Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> width = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> height = <span class="number">768</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to start GLFW\n&quot;</span>;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_SAMPLES, <span class="number">4</span>); <span class="comment">// Enable 4xMSAA</span></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_RESIZABLE, GL_FALSE);</span><br><span class="line">    m_window = <span class="built_in">glfwCreateWindow</span>(<span class="number">1024</span>, <span class="number">768</span>, <span class="string">&quot;ArkRenderer&quot;</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (!m_window)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to create GLFW m_window.\n&quot;</span>;</span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(m_window);</span><br><span class="line">    <span class="built_in">glfwFocusWindow</span>(m_window);</span><br><span class="line">    <span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>);<span class="comment">//Enable Vsync</span></span><br><span class="line">    <span class="comment">// Center window</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> mode = <span class="built_in">glfwGetVideoMode</span>(<span class="built_in">glfwGetPrimaryMonitor</span>());</span><br><span class="line">    <span class="built_in">glfwSetWindowPos</span>(m_window, (mode-&gt;width / <span class="number">2</span>) - width / <span class="number">2</span>, (mode-&gt;height / <span class="number">2</span>) - height / <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">glfwSetInputMode</span>(m_window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);</span><br><span class="line">    <span class="keyword">return</span> m_window;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>I used ‘magic numbers’, which should be avoided. But no worry about that, I will improve this later.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WindowSystem::SwapBuffers</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glfwSwapBuffers</span>(m_window);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WindowSystem::Update</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    <span class="keyword">if</span> (Input::<span class="built_in">GetInstance</span>().<span class="built_in">IsKeyPressed</span>(GLFW_KEY_TAB))</span><br><span class="line">    &#123;</span><br><span class="line">        m_showCursor = !m_showCursor;</span><br><span class="line">        <span class="keyword">if</span> (m_showCursor)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">glfwSetInputMode</span>(m_window, GLFW_CURSOR, GLFW_CURSOR_NORMAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">glfwSetInputMode</span>(m_window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if the m_window needs to be closed</span></span><br><span class="line">    <span class="keyword">if</span> (Input::<span class="built_in">GetInstance</span>().<span class="built_in">IsKeyPressed</span>(GLFW_KEY_ESCAPE) ||</span><br><span class="line">        <span class="built_in">glfwWindowShouldClose</span>(m_window))</span><br><span class="line">    &#123;</span><br><span class="line">        m_shouldClose = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">glfwSetWindowShouldClose</span>(m_window, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SwapBuffers</code> is simple. What is <code>glfwPollEvents</code>?</p><p>The <code>glfwPollEvents</code> function <strong>checks if any events are triggered (like keyboard input or mouse movement events)</strong><code>Update</code> function updates window status according to keyboard input(<code>Input.h</code>).</p><p>In <code>AkrEngine.cpp</code>, we use a function called <code>ConnectToInput</code> to handle input related with current window:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConnectToInput</span><span class="params">(GLFWwindow* window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> resizeCallback = [](GLFWwindow* w, <span class="keyword">auto</span> width, <span class="keyword">auto</span> height) &#123;</span><br><span class="line">        Input::<span class="built_in">GetInstance</span>().<span class="built_in">windowResized</span>(width, height);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">glfwSetWindowSizeCallback</span>(window, resizeCallback);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> keyCallback = [](GLFWwindow* w, <span class="keyword">auto</span> key, <span class="keyword">auto</span> scanCode, <span class="keyword">auto</span> action, <span class="keyword">auto</span> mode) &#123;</span><br><span class="line">        Input::<span class="built_in">GetInstance</span>().<span class="built_in">keyPressed</span>(key, scanCode, action, mode);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">glfwSetKeyCallback</span>(window, keyCallback);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> cursorPosCallback = [](GLFWwindow* w, <span class="keyword">auto</span> xPos, <span class="keyword">auto</span> yPos) &#123;</span><br><span class="line">        Input::<span class="built_in">GetInstance</span>().<span class="built_in">mouseMoved</span>(xPos, yPos);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">glfwSetCursorPosCallback</span>(window, cursorPosCallback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>And use our simple Window System like this:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ArkEngine::Execute</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!m_window.<span class="built_in">ShouldClose</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        Input::<span class="built_in">GetInstance</span>().<span class="built_in">Update</span>();</span><br><span class="line">        m_window.<span class="built_in">Update</span>();</span><br><span class="line">        m_renderer.<span class="built_in">Render</span>();</span><br><span class="line">        m_window.<span class="built_in">SwapBuffers</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Shutdown</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ArkEngine::Shutdown</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_window.<span class="built_in">Shutdown</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Finally, we got this:</p><p><img src="/ArkRenderer-Dev-Log-0/ark-001.png" alt="ark-001"></p><p>That’s all for today!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Window-System&quot;&gt;&lt;a href=&quot;#Window-System&quot; class=&quot;headerlink&quot; title=&quot;Window System&quot;&gt;&lt;/a&gt;Window System&lt;/h2&gt;&lt;p&gt;Lot’s of OpenGL tutorials </summary>
      
    
    
    
    <category term="computer graphics" scheme="https://proton991.github.io/categories/computer-graphics/"/>
    
    
    <category term="Renderer" scheme="https://proton991.github.io/tags/Renderer/"/>
    
    <category term="OpenGL" scheme="https://proton991.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>ArkRenderer Project</title>
    <link href="https://proton991.github.io/ArkRenderer-Project/"/>
    <id>https://proton991.github.io/ArkRenderer-Project/</id>
    <published>2022-06-17T05:51:32.000Z</published>
    <updated>2022-06-17T09:18:05.251Z</updated>
    
    <content type="html"><![CDATA[<p><em>This article will be updated during the development</em></p><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>Ark Renderer is a 3D rendering engine, I built this by referencing <strong><a href="https://github.com/htmlboss/OpenGL-Renderer">OpenGL-Renderer</a></strong>, it’s my first computer graphic project, so it’s difficult for me to start from scratch on my own. So I intend to build my project based on other projects, the final code may look similar, but I will dive deep into the code and figure out how it works. I will write dev logs along the way. OpengGL programming and basic rendering techniques will be covered.  </p><h2 id="Project-Structure"><a href="#Project-Structure" class="headerlink" title="Project Structure"></a>Project Structure</h2><p>The 3d engine is composed of several sub-systems. They are</p><ul><li>Window System</li><li>Render System</li><li>GUI System</li></ul><p>The render system is the core of the renderer.  I will create “wrappers” for raw OpenGL code and pipeline. Shaders, textures, scenes and other resources will be loaded from disk and cached in memory during runtime, so a <strong>ResourceManager</strong> is needed.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;em&gt;This article will be updated during the development&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview</summary>
      
    
    
    
    <category term="computer graphics" scheme="https://proton991.github.io/categories/computer-graphics/"/>
    
    
    <category term="Renderer" scheme="https://proton991.github.io/tags/Renderer/"/>
    
    <category term="OpenGL" scheme="https://proton991.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://proton991.github.io/hello-world/"/>
    <id>https://proton991.github.io/hello-world/</id>
    <published>2022-06-17T03:00:36.044Z</published>
    <updated>2022-06-17T03:00:36.044Z</updated>
    
    <content type="html"><![CDATA[<h1 id="My-first-hexo-blog"><a href="#My-first-hexo-blog" class="headerlink" title="My first hexo blog."></a>My first hexo blog.</h1><p>Keep doing and do it well.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;My-first-hexo-blog&quot;&gt;&lt;a href=&quot;#My-first-hexo-blog&quot; class=&quot;headerlink&quot; title=&quot;My first hexo blog.&quot;&gt;&lt;/a&gt;My first hexo blog.&lt;/h1&gt;&lt;p&gt;Keep</summary>
      
    
    
    
    <category term="Talk" scheme="https://proton991.github.io/categories/Talk/"/>
    
    
  </entry>
  
  <entry>
    <title>LearnCpp-day0</title>
    <link href="https://proton991.github.io/LearnCpp-day0/"/>
    <id>https://proton991.github.io/LearnCpp-day0/</id>
    <published>2022-03-15T05:18:53.000Z</published>
    <updated>2022-06-17T03:00:36.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Learn-CPP-Overview"><a href="#Learn-CPP-Overview" class="headerlink" title="Learn CPP - Overview"></a>Learn CPP - Overview</h2><p>C++ syntax is so complicated that I can’t grasp all of them, so I decided to learn c++ by coding some projects (apart form CG proects).</p><p><strong>Resources</strong>:</p><ol><li><a href="https://github.com/Alinshans/MyTinySTL">MyTinySTL</a></li><li><a href="https://github.com/huihut/interview">Cpp Interview</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus">TheAlgorithms&#x2F;C-Plus-Plus</a></li><li><a href="https://github.com/wisdompeak/LeetCode">LeetCode C++</a></li></ol><p><strong>Learning Schedule</strong></p><ol><li>Build my own version of STL.</li><li>Build algorithm libarary using c++.</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Learn-CPP-Overview&quot;&gt;&lt;a href=&quot;#Learn-CPP-Overview&quot; class=&quot;headerlink&quot; title=&quot;Learn CPP - Overview&quot;&gt;&lt;/a&gt;Learn CPP - Overview&lt;/h2&gt;&lt;p&gt;C+</summary>
      
    
    
    
    <category term="Cpp" scheme="https://proton991.github.io/categories/Cpp/"/>
    
    
    <category term="c++" scheme="https://proton991.github.io/tags/c/"/>
    
    <category term="algorithm" scheme="https://proton991.github.io/tags/algorithm/"/>
    
    <category term="c++ STL" scheme="https://proton991.github.io/tags/c-STL/"/>
    
  </entry>
  
  <entry>
    <title>RayTraycing-day0</title>
    <link href="https://proton991.github.io/RayTraycing-day0/"/>
    <id>https://proton991.github.io/RayTraycing-day0/</id>
    <published>2022-03-14T12:27:21.000Z</published>
    <updated>2022-06-17T03:00:36.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Overview-Learn-Raytracing-from-theory-to-practice"><a href="#Overview-Learn-Raytracing-from-theory-to-practice" class="headerlink" title="Overview: Learn Raytracing - from theory to practice"></a>Overview: Learn Raytracing - from theory to practice</h2><p>Ray tracing is <strong>a method of graphics rendering that simulates the physical behavior of light</strong>. We can produce photorealistic images using ray tracing algorithms. I decided to learn the whole process of rendering from scratch and finally build my own raytracer. </p> <br /><p><strong>Resources</strong>:</p><ol><li><p><a href="https://www.scratchapixel.com/index.php">Scratchapixel</a></p></li><li><p><a href="https://graphicscodex.courses.nvidia.com/app.html">Graphics Codex</a></p></li><li><p><a href="https://www.youtube.com/playlist?list=PLujxSBD-JXgnGmsn7gEyN28P1DnRZG7qi">TU Wien Rendering Course</a></p></li><li><p>Fundamentals of Computer Graphics, Fourth Edition (2016)</p></li><li><p>Physically Based Rendering From Theory to Implementation  (2016)</p></li></ol> <br /><p><strong>Projects</strong>:</p><ol><li><p><a href="https://raytracing.github.io/">Ray Tracing in One Weekend</a></p></li><li><p><a href="https://users.cg.tuwien.ac.at/zsolnai/gfx/smallpaint/">Smallpaint</a></p></li><li><p><a href="https://github.com/knightcrawler25/GLSL-PathTracer">GLSL-PathTracer</a></p></li><li><p><a href="https://github.com/define-private-public/PSRayTracing">PSRayTracing</a></p></li><li><p><a href="https://github.com/linusmossberg/monte-carlo-ray-tracer">monte-carlo-ray-tracer</a></p></li><li><p><a href="https://nvpro-samples.github.io/vk_mini_path_tracer/index.html">vk_mini_path_tracer</a></p></li></ol> <br /><p><strong>Learning Schedule</strong>:</p><p><strong>LO0</strong>: Basics concepts, algorithms in computer graphics&#x2F;rendering.</p><p><strong>LO1</strong>: Follow Ray Tracing in One Weekend Series and code with it.</p><p><strong>LO2</strong>: Refactor the code in <strong>LO1</strong> (referencing PSRayTracing and Smallpaint), build a retracer with GUI in which you can select scene and configure paramenters for raytracer.</p><p><strong>LO3</strong>: Learn OpenGL and Read the source code of GLSL-PathTracer thoroughly.</p><p><strong>LO4</strong>: Learn Vulkan and follow the tutorial vk_mini_path_tracer and finally build a Vulkan-pathtracer.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Overview-Learn-Raytracing-from-theory-to-practice&quot;&gt;&lt;a href=&quot;#Overview-Learn-Raytracing-from-theory-to-practice&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    <category term="computer graphics" scheme="https://proton991.github.io/categories/computer-graphics/"/>
    
    
    <category term="ray-tracing" scheme="https://proton991.github.io/tags/ray-tracing/"/>
    
    <category term="computer-graphics" scheme="https://proton991.github.io/tags/computer-graphics/"/>
    
  </entry>
  
</feed>
